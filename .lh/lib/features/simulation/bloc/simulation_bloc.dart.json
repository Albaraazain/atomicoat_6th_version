{
    "sourceFile": "lib/features/simulation/bloc/simulation_bloc.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1734376760288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1734376760288,
            "name": "Commit-0",
            "content": "\r\nimport 'dart:async';\r\nimport 'dart:math';\r\nimport 'package:bloc/bloc.dart';\r\nimport 'package:experiment_planner/blocs/simulation/models/component_simulation_behavior.dart';\r\nimport 'package:experiment_planner/features/components/models/system_component.dart';\r\nimport 'package:experiment_planner/features/alarms/models/alarm.dart';\r\nimport 'package:experiment_planner/features/safety/models/safety_error.dart';\r\nimport 'package:experiment_planner/blocs/component/bloc/component_bloc.dart';\r\nimport 'package:experiment_planner/blocs/component/bloc/component_event.dart';\r\nimport 'package:experiment_planner/blocs/alarm/bloc/alarm_bloc.dart';\r\nimport 'package:experiment_planner/blocs/alarm/bloc/alarm_event.dart';\r\nimport 'package:experiment_planner/blocs/safety/bloc/safety_bloc.dart';\r\nimport 'package:experiment_planner/blocs/safety/bloc/safety_event.dart';\r\nimport 'package:experiment_planner/core/utils/bloc_utils.dart';\r\nimport 'package:experiment_planner/blocs/simulation/bloc/simulation_event.dart';\r\nimport 'package:experiment_planner/blocs/simulation/bloc/simulation_state.dart';\r\n\r\nclass SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n  final ComponentBloc _componentBloc;\r\n  final AlarmBloc _alarmBloc;\r\n  final SafetyBloc _safetyBloc;\r\n  final Random _random; // Make Random injectable\r\n  Timer? _simulationTimer;\r\n\r\n  static const int SIMULATION_INTERVAL_MS = 500;\r\n\r\n  SimulationBloc({\r\n    required ComponentBloc componentBloc,\r\n    required AlarmBloc alarmBloc,\r\n    required SafetyBloc safetyBloc,\r\n    Random? random, // Add optional random parameter\r\n  })  : _componentBloc = componentBloc,\r\n        _alarmBloc = alarmBloc,\r\n        _safetyBloc = safetyBloc,\r\n        _random = random ?? Random(), // Use provided random or create new one\r\n        super(SimulationState.initial()) {\r\n    on<StartSimulation>(_onStartSimulation);\r\n    on<StopSimulation>(_onStopSimulation);\r\n    on<SimulationTick>(_onSimulationTick);\r\n    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n    on<GenerateRandomError>(_onGenerateRandomError);\r\n  }\r\n\r\n  Future<void> _onStartSimulation(\r\n    StartSimulation event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    if (state.status == SimulationStatus.running) return;\r\n\r\n    _simulationTimer?.cancel();\r\n    _simulationTimer = Timer.periodic(\r\n      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n      (_) => add(SimulationTick()),\r\n    );\r\n\r\n    final newState = state.copyWith(\r\n      status: SimulationStatus.running,\r\n      tickCount: 0,\r\n      lastComponentUpdates: {},\r\n    );\r\n    emit(newState);\r\n\r\n    _alarmBloc.add(AddAlarm(\r\n      message: 'Simulation started',\r\n      severity: AlarmSeverity.info,\r\n    ));\r\n  }\r\n\r\n  Future<void> _onStopSimulation(\r\n    StopSimulation event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    _simulationTimer?.cancel();\r\n    _simulationTimer = null;\r\n\r\n    // Important: emit state before adding alarm\r\n    emit(state.copyWith(\r\n      status: SimulationStatus.idle,\r\n      lastUpdated: DateTime.now(),\r\n    ));\r\n\r\n    _alarmBloc.add(AddAlarm(\r\n      message: 'Simulation stopped',\r\n      severity: AlarmSeverity.info,\r\n    ));\r\n  }\r\n\r\n  Future<void> _onGenerateRandomError(\r\n    GenerateRandomError event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    final isComponentError = _random.nextBool();\r\n\r\n    // Always emit a state to acknowledge the event\r\n    emit(state.copyWith(\r\n      lastUpdated: DateTime.now(),\r\n    ));\r\n\r\n    if (isComponentError) {\r\n      final componentName = _getRandomComponent();\r\n      _componentBloc.add(ComponentErrorAdded(\r\n        componentName,\r\n        'Simulated malfunction detected',\r\n      ));\r\n\r\n      final component = SystemComponent(\r\n        name: componentName,\r\n        description: '',\r\n        currentValues: {},\r\n        setValues: {},\r\n      );\r\n      component.status = ComponentStatus.error;\r\n\r\n      _componentBloc.add(ComponentStatusUpdated(\r\n        componentName,\r\n        component.status,\r\n      ));\r\n    } else {\r\n      _safetyBloc.add(SafetyErrorDetected(\r\n        SafetyError(\r\n          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n          description: 'Simulated safety error detected',\r\n          severity: _random.nextBool()\r\n              ? SafetyErrorSeverity.warning\r\n              : SafetyErrorSeverity.critical,\r\n        ),\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onSimulationTick(\r\n    SimulationTick event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    if (state.status != SimulationStatus.running) return;\r\n\r\n    try {\r\n      // Update component values\r\n      final updates = _generateComponentUpdates();\r\n      if (updates.isNotEmpty) {\r\n        add(UpdateComponentValues(updates));\r\n      }\r\n\r\n      // Check safety conditions\r\n      add(CheckSafetyConditions());\r\n\r\n      // Occasionally generate random errors\r\n      if (_random.nextDouble() < 0.05) {\r\n        // 5% chance per tick\r\n        add(GenerateRandomError());\r\n      }\r\n\r\n      emit(state.copyWith(\r\n        tickCount: state.tickCount + 1,\r\n        lastUpdated: event.timestamp,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        status: SimulationStatus.error,\r\n        error: BlocUtils.handleError(error),\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onUpdateComponentValues(\r\n    UpdateComponentValues event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    try {\r\n      // Update primary components\r\n      for (var entry in event.updates.entries) {\r\n        _componentBloc.add(ComponentValueUpdated(\r\n          entry.key,\r\n          entry.value,\r\n        ));\r\n      }\r\n\r\n      // Handle dependencies\r\n      final dependencyUpdates = _processDependencies(event.updates);\r\n      if (dependencyUpdates.isNotEmpty) {\r\n        for (var entry in dependencyUpdates.entries) {\r\n          _componentBloc.add(ComponentValueUpdated(\r\n            entry.key,\r\n            entry.value,\r\n          ));\r\n        }\r\n      }\r\n\r\n      emit(state.copyWith(\r\n        lastComponentUpdates: {\r\n          ...state.lastComponentUpdates,\r\n          for (var component in event.updates.keys) component: DateTime.now(),\r\n        },\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n    }\r\n  }\r\n\r\n  Future<void> _onCheckSafetyConditions(\r\n    CheckSafetyConditions event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    // Check chamber conditions\r\n    _checkReactionChamber();\r\n\r\n    // Check other critical components\r\n    _checkCriticalComponents();\r\n  }\r\n\r\n  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n    final updates = <String, Map<String, double>>{};\r\n\r\n    for (var entry in state.componentBehaviors.entries) {\r\n      final componentName = entry.key;\r\n      final behavior = entry.value;\r\n\r\n      // Get current values from component\r\n      final component = _getComponentState(componentName);\r\n      if (component != null && component.isActivated) {\r\n        final newValues = behavior.generateValues(component.currentValues);\r\n\r\n        // Only include if values changed and are valid\r\n        if (_hasValuesChanged(component.currentValues, newValues) &&\r\n            behavior.validateValues(newValues)) {\r\n          updates[componentName] = newValues;\r\n        }\r\n      }\r\n    }\r\n\r\n    return updates;\r\n  }\r\n\r\n  SystemComponent? _getComponentState(String componentName) {\r\n    try {\r\n      _componentBloc.add(ComponentInitialized(componentName));\r\n      return _componentBloc.state.component;\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  bool _hasValuesChanged(\r\n    Map<String, double> current,\r\n    Map<String, double> newValues,\r\n  ) {\r\n    return newValues.entries.any((entry) {\r\n      final currentValue = current[entry.key];\r\n      return currentValue == null ||\r\n          (currentValue - entry.value).abs() > 0.0001;\r\n    });\r\n  }\r\n\r\n  Map<String, Map<String, double>> _processDependencies(\r\n    Map<String, Map<String, double>> updates,\r\n  ) {\r\n    final dependencyUpdates = <String, Map<String, double>>{};\r\n\r\n    for (var entry in updates.entries) {\r\n      final dependencies = state.dependencies[entry.key] ?? [];\r\n\r\n      for (var dependentName in dependencies) {\r\n        final behavior = state.componentBehaviors[dependentName];\r\n        if (behavior != null) {\r\n          final currentValues =\r\n              _getComponentState(dependentName)?.currentValues ?? {};\r\n          final newValues = behavior.generateValues(currentValues);\r\n\r\n          // Apply dependency factors\r\n          if (entry.key == 'MFC' &&\r\n              dependentName == 'Nitrogen Generator' &&\r\n              entry.value.containsKey('flow_rate')) {\r\n            newValues['flow_rate'] = entry.value['flow_rate']! * 0.8;\r\n          }\r\n\r\n          if (behavior.validateValues(newValues)) {\r\n            dependencyUpdates[dependentName] = newValues;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return dependencyUpdates;\r\n  }\r\n\r\n  void _checkReactionChamber() {\r\n    final behavior =\r\n        state.componentBehaviors['Reaction Chamber'] as ReactorChamberBehavior?;\r\n    if (behavior == null) return;\r\n\r\n    final chamber = _getComponentState('Reaction Chamber');\r\n    if (chamber != null) {\r\n      final values = chamber.currentValues;\r\n      if (!behavior.validateValues(values)) {\r\n        _safetyBloc.add(SafetyErrorDetected(\r\n          SafetyError(\r\n            id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n            description: 'Reaction chamber parameters out of safe range',\r\n            severity: SafetyErrorSeverity.critical,\r\n          ),\r\n        ));\r\n      }\r\n    }\r\n  }\r\n\r\n  void _checkCriticalComponents() {\r\n    for (var entry in state.componentBehaviors.entries) {\r\n      if (_isCriticalComponent(entry.key)) {\r\n        final component = _getComponentState(entry.key);\r\n        if (component != null) {\r\n          if (!entry.value.validateValues(component.currentValues)) {\r\n            _safetyBloc.add(SafetyErrorDetected(\r\n              SafetyError(\r\n                id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n                description: '${entry.key} parameters out of safe range',\r\n                severity: SafetyErrorSeverity.warning,\r\n              ),\r\n            ));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  bool _isCriticalComponent(String componentName) {\r\n    return [\r\n      'MFC',\r\n      'Pressure Control System',\r\n      'Vacuum Pump',\r\n    ].contains(componentName);\r\n  }\r\n\r\n  double _generateNewValue(\r\n      String parameter, double setpoint, double fluctuation) {\r\n    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n    return setpoint + delta;\r\n  }\r\n\r\n  double _adjustDependentValue(\r\n    double baseValue,\r\n    double factor,\r\n    double fluctuation,\r\n  ) {\r\n    return baseValue * factor +\r\n        _random.nextDouble() * fluctuation * 2 -\r\n        fluctuation;\r\n  }\r\n\r\n  String _getRandomComponent() {\r\n    const components = [\r\n      'Reaction Chamber',\r\n      'MFC',\r\n      'Vacuum Pump',\r\n      'Pressure Control System',\r\n    ];\r\n    return components[_random.nextInt(components.length)];\r\n  }\r\n\r\n  @override\r\n  Future<void> close() {\r\n    _simulationTimer?.cancel();\r\n    return super.close();\r\n  }\r\n}\r\n"
        }
    ]
}