{
    "sourceFile": "lib/features/system/bloc/system_state_bloc.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1734376765315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1734376765315,
            "name": "Commit-0",
            "content": "^// *(lib|path)// lib/blocs/system_state/bloc/system_state_bloc.dart\r\n\r\nimport 'dart:async';\r\nimport 'package:bloc/bloc.dart';\r\nimport 'package:experiment_planner/features/system/repositories/system_state_repository.dart';\r\nimport '../../utils/bloc_utils.dart';\r\nimport '../models/system_state_data.dart';\r\nimport 'system_state_event.dart';\r\nimport 'system_state_state.dart';\r\n\r\nclass SystemStateBloc extends Bloc<SystemStateEvent, SystemStateState> {\r\n  final SystemStateRepository _repository;\r\n  StreamSubscription? _stateSubscription;\r\n\r\n  SystemStateBloc(this._repository) : super(SystemStateState()) {\r\n    on<InitializeSystem>(_onInitializeSystem);\r\n    on<StartSystem>(_onStartSystem);\r\n    on<StopSystem>(_onStopSystem);\r\n    on<EmergencyStop>(_onEmergencyStop);\r\n    on<CheckSystemReadiness>(_onCheckSystemReadiness);\r\n    on<SaveSystemState>(_onSaveSystemState);\r\n    on<ValidateSystemState>(_onValidateSystemState);\r\n    on<UpdateSystemParameters>(_onUpdateSystemParameters);\r\n  }\r\n\r\n  Future<void> _onInitializeSystem(\r\n    InitializeSystem event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(\r\n        status: SystemOperationalStatus.initializing,\r\n        isLoading: true,\r\n      ));\r\n\r\n      // Load the latest state\r\n      final latestState = await _repository.getSystemState();\r\n\r\n      if (latestState != null) {\r\n        emit(state.copyWith(\r\n          status: SystemOperationalStatus.ready,\r\n          currentSystemState: latestState.data,\r\n          lastStateUpdate: latestState.timestamp,\r\n          isLoading: false,\r\n        ));\r\n      } else {\r\n        emit(state.copyWith(\r\n          status: SystemOperationalStatus.ready,\r\n          isLoading: false,\r\n        ));\r\n      }\r\n\r\n      // Setup state subscription\r\n      await _stateSubscription?.cancel();\r\n      _stateSubscription = _repository.systemStateStream().listen(\r\n        (systemState) {\r\n          if (systemState != null) {\r\n            add(SaveSystemState(systemState.data));\r\n          }\r\n        },\r\n        onError: (error) {\r\n          add(SaveSystemState({'error': error.toString()}));\r\n        },\r\n      );\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        status: SystemOperationalStatus.error,\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onStartSystem(\r\n    StartSystem event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    if (!state.canStart) {\r\n      emit(state.copyWith(\r\n        error: 'System cannot be started in current state',\r\n      ));\r\n      return;\r\n    }\r\n\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      await _repository.saveSystemState({\r\n        'status': 'running',\r\n        'isSystemRunning': true,\r\n        'timestamp': DateTime.now().toIso8601String(),\r\n      });\r\n\r\n      emit(state.copyWith(\r\n        status: SystemOperationalStatus.running,\r\n        isSystemRunning: true,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onStopSystem(\r\n    StopSystem event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    if (!state.canStop) {\r\n      emit(state.copyWith(\r\n        error: 'System is not running',\r\n      ));\r\n      return;\r\n    }\r\n\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      await _repository.saveSystemState({\r\n        'status': 'ready',\r\n        'isSystemRunning': false,\r\n        'timestamp': DateTime.now().toIso8601String(),\r\n      });\r\n\r\n      emit(state.copyWith(\r\n        status: SystemOperationalStatus.ready,\r\n        isSystemRunning: false,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onEmergencyStop(\r\n    EmergencyStop event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      await _repository.saveSystemState({\r\n        ...state.currentSystemState,\r\n        'isRunning': false,\r\n        'emergencyStoppedAt': DateTime.now().toIso8601String(),\r\n        'timestamp': DateTime.now().toIso8601String(),\r\n      });\r\n\r\n      emit(state.copyWith(\r\n        status: SystemOperationalStatus.emergencyStopped,\r\n        isSystemRunning: false,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onCheckSystemReadiness(\r\n    CheckSystemReadiness event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      // Implement system readiness checks here\r\n      final issues = _checkSystemIssues();\r\n\r\n      emit(state.copyWith(\r\n        systemIssues: issues,\r\n        isReadinessCheckPassed: issues.isEmpty,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onSaveSystemState(\r\n    SaveSystemState event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      await _repository.saveSystemState({\r\n        ...event.state,\r\n        'timestamp': DateTime.now().toIso8601String(),\r\n      });\r\n\r\n      emit(state.copyWith(\r\n        currentSystemState: event.state,\r\n        lastStateUpdate: DateTime.now(),\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onValidateSystemState(\r\n    ValidateSystemState event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      // Implement state validation logic here\r\n      final issues = _validateCurrentState();\r\n\r\n      emit(state.copyWith(\r\n        systemIssues: issues,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onUpdateSystemParameters(\r\n    UpdateSystemParameters event,\r\n    Emitter<SystemStateState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      final updatedState = Map<String, dynamic>.from(state.currentSystemState);\r\n      event.updates.forEach((component, values) {\r\n        if (updatedState.containsKey('components')) {\r\n          final components = updatedState['components'] as Map<String, dynamic>;\r\n          if (components.containsKey(component)) {\r\n            final componentData = components[component] as Map<String, dynamic>;\r\n            componentData['currentValues'] = values;\r\n          }\r\n        }\r\n      });\r\n\r\n      await _repository.saveSystemState(updatedState);\r\n\r\n      emit(state.copyWith(\r\n        currentSystemState: updatedState,\r\n        lastStateUpdate: DateTime.now(),\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  List<String> _checkSystemIssues() {\r\n    final issues = <String>[];\r\n\r\n    final components = state.currentSystemState['components'] as Map<String, dynamic>?;\r\n\r\n    if (components == null || components.isEmpty) {\r\n      issues.add('No components found in system');\r\n      return issues;\r\n    }\r\n\r\n    components.forEach((componentName, componentData) {\r\n      final data = componentData as Map<String, dynamic>;\r\n      final isActivated = data['isActivated'] as bool? ?? false;\r\n      final currentValues = data['currentValues'] as Map<String, dynamic>?;\r\n      final setValues = data['setValues'] as Map<String, dynamic>?;\r\n\r\n      if (!isActivated) {\r\n        issues.add('$componentName is not activated');\r\n      }\r\n\r\n      if (currentValues != null && setValues != null) {\r\n        currentValues.forEach((parameter, value) {\r\n          final setValue = setValues[parameter];\r\n          if (setValue != null && (value as num).abs() - (setValue as num).abs() > 0.1) {\r\n            issues.add('$componentName: $parameter mismatch (current: $value, set: $setValue)');\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return issues;\r\n  }\r\n\r\n  List<String> _validateCurrentState() {\r\n    final issues = <String>[];\r\n\r\n    if (!state.isSystemRunning && state.status == SystemOperationalStatus.running) {\r\n      issues.add('System status inconsistency detected');\r\n    }\r\n\r\n    final components = state.currentSystemState['components'] as Map<String, dynamic>?;\r\n    if (components != null) {\r\n      components.forEach((componentName, componentData) {\r\n        final data = componentData as Map<String, dynamic>;\r\n        final currentValues = data['currentValues'] as Map<String, dynamic>?;\r\n        final minValues = data['minValues'] as Map<String, dynamic>?;\r\n        final maxValues = data['maxValues'] as Map<String, dynamic>?;\r\n\r\n        if (currentValues != null && minValues != null && maxValues != null) {\r\n          currentValues.forEach((parameter, value) {\r\n            final min = minValues[parameter] as num?;\r\n            final max = maxValues[parameter] as num?;\r\n            final current = value as num;\r\n\r\n            if (min != null && current < min) {\r\n              issues.add('$componentName: $parameter below minimum ($current < $min)');\r\n            }\r\n            if (max != null && current > max) {\r\n              issues.add('$componentName: $parameter above maximum ($current > $max)');\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  @override\r\n  Future<void> close() {\r\n    _stateSubscription?.cancel();\r\n    return super.close();\r\n  }\r\n}"
        }
    ]
}