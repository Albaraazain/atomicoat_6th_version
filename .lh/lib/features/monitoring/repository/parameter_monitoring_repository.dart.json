{
    "sourceFile": "lib/features/monitoring/repository/parameter_monitoring_repository.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1734376760298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1734434512818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,101 @@\n+\r\n+import 'package:cloud_firestore/cloud_firestore.dart';\r\n+import '../../components/models/data_point.dart';\r\n+\r\n+class ParameterMonitoringRepository extends BlocRepository<Map<String, dynamic>> {\r\n+  static const int MAX_HISTORY_POINTS = 1000;\r\n+\r\n+  ParameterMonitoringRepository({String? userId}) : super(\r\n+    collectionName: 'parameter_monitoring',\r\n+    userId: userId,\r\n+  );\r\n+\r\n+  @override\r\n+  Map<String, dynamic> fromJson(Map<String, dynamic> json) => json;\r\n+\r\n+  @override\r\n+  Map<String, dynamic> toJson(Map<String, dynamic> data) => data;\r\n+\r\n+  Future<void> saveParameterValue(\r\n+    String componentId,\r\n+    String parameterName,\r\n+    DataPoint dataPoint,\r\n+  ) async {\r\n+    final docRef = userCollection\r\n+        .doc(componentId)\r\n+        .collection('parameters')\r\n+        .doc(parameterName)\r\n+        .collection('history')\r\n+        .doc(dataPoint.timestamp.millisecondsSinceEpoch.toString());\r\n+\r\n+    await docRef.set(dataPoint.toJson());\r\n+\r\n+    // Cleanup old data points\r\n+    final oldData = await userCollection\r\n+        .doc(componentId)\r\n+        .collection('parameters')\r\n+        .doc(parameterName)\r\n+        .collection('history')\r\n+        .orderBy('timestamp', descending: true)\r\n+        .limit(MAX_HISTORY_POINTS + 1)\r\n+        .get();\r\n+\r\n+    if (oldData.docs.length > MAX_HISTORY_POINTS) {\r\n+      final batch = FirebaseFirestore.instance.batch();\r\n+      oldData.docs\r\n+          .sublist(MAX_HISTORY_POINTS)\r\n+          .forEach((doc) => batch.delete(doc.reference));\r\n+      await batch.commit();\r\n+    }\r\n+  }\r\n+\r\n+  Stream<List<DataPoint>> watchParameterHistory(\r\n+    String componentId,\r\n+    String parameterName,\r\n+    Duration duration,\r\n+  ) {\r\n+    final cutoff = DateTime.now().subtract(duration);\r\n+\r\n+    return userCollection\r\n+        .doc(componentId)\r\n+        .collection('parameters')\r\n+        .doc(parameterName)\r\n+        .collection('history')\r\n+        .where('timestamp', isGreaterThan: cutoff.millisecondsSinceEpoch)\r\n+        .orderBy('timestamp', descending: true)\r\n+        .limit(MAX_HISTORY_POINTS)\r\n+        .snapshots()\r\n+        .map((snapshot) => snapshot.docs\r\n+            .map((doc) => DataPoint.fromJson(doc.data()))\r\n+            .toList());\r\n+  }\r\n+\r\n+  Future<void> saveThresholds(\r\n+    String componentId,\r\n+    String parameterName,\r\n+    double minValue,\r\n+    double maxValue,\r\n+  ) async {\r\n+    await save('thresholds/$componentId/$parameterName', {\r\n+      'min': minValue,\r\n+      'max': maxValue,\r\n+      'updatedAt': FieldValue.serverTimestamp(),\r\n+    });\r\n+  }\r\n+\r\n+  Future<Map<String, Map<String, double>>> getThresholds(String componentId) async {\r\n+    final doc = await get('thresholds/$componentId');\r\n+    if (doc == null) return {};\r\n+\r\n+    final thresholds = <String, Map<String, double>>{};\r\n+    doc.forEach((parameter, value) {\r\n+      if (value is Map) {\r\n+        thresholds[parameter] = {\r\n+          'min': (value['min'] as num).toDouble(),\r\n+          'max': (value['max'] as num).toDouble(),\r\n+        };\r\n+      }\r\n+    });\r\n+    return thresholds;\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734434519955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,101 @@\n+\r\n+import 'package:cloud_firestore/cloud_firestore.dart';\r\n+import '../../components/models/data_point.dart';\r\n+\r\n+class ParameterMonitoringRepository extends BlocRepository<Map<String, dynamic>> {\r\n+  static const int MAX_HISTORY_POINTS = 1000;\r\n+\r\n+  ParameterMonitoringRepository({String? userId}) : super(\r\n+    collectionName: 'parameter_monitoring',\r\n+    userId: userId,\r\n+  );\r\n+\r\n+  @override\r\n+  Map<String, dynamic> fromJson(Map<String, dynamic> json) => json;\r\n+\r\n+  @override\r\n+  Map<String, dynamic> toJson(Map<String, dynamic> data) => data;\r\n+\r\n+  Future<void> saveParameterValue(\r\n+    String componentId,\r\n+    String parameterName,\r\n+    DataPoint dataPoint,\r\n+  ) async {\r\n+    final docRef = userCollection\r\n+        .doc(componentId)\r\n+        .collection('parameters')\r\n+        .doc(parameterName)\r\n+        .collection('history')\r\n+        .doc(dataPoint.timestamp.millisecondsSinceEpoch.toString());\r\n+\r\n+    await docRef.set(dataPoint.toJson());\r\n+\r\n+    // Cleanup old data points\r\n+    final oldData = await userCollection\r\n+        .doc(componentId)\r\n+        .collection('parameters')\r\n+        .doc(parameterName)\r\n+        .collection('history')\r\n+        .orderBy('timestamp', descending: true)\r\n+        .limit(MAX_HISTORY_POINTS + 1)\r\n+        .get();\r\n+\r\n+    if (oldData.docs.length > MAX_HISTORY_POINTS) {\r\n+      final batch = FirebaseFirestore.instance.batch();\r\n+      oldData.docs\r\n+          .sublist(MAX_HISTORY_POINTS)\r\n+          .forEach((doc) => batch.delete(doc.reference));\r\n+      await batch.commit();\r\n+    }\r\n+  }\r\n+\r\n+  Stream<List<DataPoint>> watchParameterHistory(\r\n+    String componentId,\r\n+    String parameterName,\r\n+    Duration duration,\r\n+  ) {\r\n+    final cutoff = DateTime.now().subtract(duration);\r\n+\r\n+    return userCollection\r\n+        .doc(componentId)\r\n+        .collection('parameters')\r\n+        .doc(parameterName)\r\n+        .collection('history')\r\n+        .where('timestamp', isGreaterThan: cutoff.millisecondsSinceEpoch)\r\n+        .orderBy('timestamp', descending: true)\r\n+        .limit(MAX_HISTORY_POINTS)\r\n+        .snapshots()\r\n+        .map((snapshot) => snapshot.docs\r\n+            .map((doc) => DataPoint.fromJson(doc.data()))\r\n+            .toList());\r\n+  }\r\n+\r\n+  Future<void> saveThresholds(\r\n+    String componentId,\r\n+    String parameterName,\r\n+    double minValue,\r\n+    double maxValue,\r\n+  ) async {\r\n+    await save('thresholds/$componentId/$parameterName', {\r\n+      'min': minValue,\r\n+      'max': maxValue,\r\n+      'updatedAt': FieldValue.serverTimestamp(),\r\n+    });\r\n+  }\r\n+\r\n+  Future<Map<String, Map<String, double>>> getThresholds(String componentId) async {\r\n+    final doc = await get('thresholds/$componentId');\r\n+    if (doc == null) return {};\r\n+\r\n+    final thresholds = <String, Map<String, double>>{};\r\n+    doc.forEach((parameter, value) {\r\n+      if (value is Map) {\r\n+        thresholds[parameter] = {\r\n+          'min': (value['min'] as num).toDouble(),\r\n+          'max': (value['max'] as num).toDouble(),\r\n+        };\r\n+      }\r\n+    });\r\n+    return thresholds;\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734434587745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,208 +97,5 @@\n       }\r\n     });\r\n     return thresholds;\r\n   }\r\n-}\n-\r\n-import 'package:cloud_firestore/cloud_firestore.dart';\r\n-import '../../components/models/data_point.dart';\r\n-\r\n-class ParameterMonitoringRepository extends BlocRepository<Map<String, dynamic>> {\r\n-  static const int MAX_HISTORY_POINTS = 1000;\r\n-\r\n-  ParameterMonitoringRepository({String? userId}) : super(\r\n-    collectionName: 'parameter_monitoring',\r\n-    userId: userId,\r\n-  );\r\n-\r\n-  @override\r\n-  Map<String, dynamic> fromJson(Map<String, dynamic> json) => json;\r\n-\r\n-  @override\r\n-  Map<String, dynamic> toJson(Map<String, dynamic> data) => data;\r\n-\r\n-  Future<void> saveParameterValue(\r\n-    String componentId,\r\n-    String parameterName,\r\n-    DataPoint dataPoint,\r\n-  ) async {\r\n-    final docRef = userCollection\r\n-        .doc(componentId)\r\n-        .collection('parameters')\r\n-        .doc(parameterName)\r\n-        .collection('history')\r\n-        .doc(dataPoint.timestamp.millisecondsSinceEpoch.toString());\r\n-\r\n-    await docRef.set(dataPoint.toJson());\r\n-\r\n-    // Cleanup old data points\r\n-    final oldData = await userCollection\r\n-        .doc(componentId)\r\n-        .collection('parameters')\r\n-        .doc(parameterName)\r\n-        .collection('history')\r\n-        .orderBy('timestamp', descending: true)\r\n-        .limit(MAX_HISTORY_POINTS + 1)\r\n-        .get();\r\n-\r\n-    if (oldData.docs.length > MAX_HISTORY_POINTS) {\r\n-      final batch = FirebaseFirestore.instance.batch();\r\n-      oldData.docs\r\n-          .sublist(MAX_HISTORY_POINTS)\r\n-          .forEach((doc) => batch.delete(doc.reference));\r\n-      await batch.commit();\r\n-    }\r\n-  }\r\n-\r\n-  Stream<List<DataPoint>> watchParameterHistory(\r\n-    String componentId,\r\n-    String parameterName,\r\n-    Duration duration,\r\n-  ) {\r\n-    final cutoff = DateTime.now().subtract(duration);\r\n-\r\n-    return userCollection\r\n-        .doc(componentId)\r\n-        .collection('parameters')\r\n-        .doc(parameterName)\r\n-        .collection('history')\r\n-        .where('timestamp', isGreaterThan: cutoff.millisecondsSinceEpoch)\r\n-        .orderBy('timestamp', descending: true)\r\n-        .limit(MAX_HISTORY_POINTS)\r\n-        .snapshots()\r\n-        .map((snapshot) => snapshot.docs\r\n-            .map((doc) => DataPoint.fromJson(doc.data()))\r\n-            .toList());\r\n-  }\r\n-\r\n-  Future<void> saveThresholds(\r\n-    String componentId,\r\n-    String parameterName,\r\n-    double minValue,\r\n-    double maxValue,\r\n-  ) async {\r\n-    await save('thresholds/$componentId/$parameterName', {\r\n-      'min': minValue,\r\n-      'max': maxValue,\r\n-      'updatedAt': FieldValue.serverTimestamp(),\r\n-    });\r\n-  }\r\n-\r\n-  Future<Map<String, Map<String, double>>> getThresholds(String componentId) async {\r\n-    final doc = await get('thresholds/$componentId');\r\n-    if (doc == null) return {};\r\n-\r\n-    final thresholds = <String, Map<String, double>>{};\r\n-    doc.forEach((parameter, value) {\r\n-      if (value is Map) {\r\n-        thresholds[parameter] = {\r\n-          'min': (value['min'] as num).toDouble(),\r\n-          'max': (value['max'] as num).toDouble(),\r\n-        };\r\n-      }\r\n-    });\r\n-    return thresholds;\r\n-  }\r\n-}\n-\r\n-import 'package:cloud_firestore/cloud_firestore.dart';\r\n-import '../../components/models/data_point.dart';\r\n-import '../../../base/base_repository.dart';\r\n-\r\n-class ParameterMonitoringRepository extends BlocRepository<Map<String, dynamic>> {\r\n-  static const int MAX_HISTORY_POINTS = 1000;\r\n-\r\n-  ParameterMonitoringRepository({String? userId}) : super(\r\n-    collectionName: 'parameter_monitoring',\r\n-    userId: userId,\r\n-  );\r\n-\r\n-  @override\r\n-  Map<String, dynamic> fromJson(Map<String, dynamic> json) => json;\r\n-\r\n-  @override\r\n-  Map<String, dynamic> toJson(Map<String, dynamic> data) => data;\r\n-\r\n-  Future<void> saveParameterValue(\r\n-    String componentId,\r\n-    String parameterName,\r\n-    DataPoint dataPoint,\r\n-  ) async {\r\n-    final docRef = userCollection\r\n-        .doc(componentId)\r\n-        .collection('parameters')\r\n-        .doc(parameterName)\r\n-        .collection('history')\r\n-        .doc(dataPoint.timestamp.millisecondsSinceEpoch.toString());\r\n-\r\n-    await docRef.set(dataPoint.toJson());\r\n-\r\n-    // Cleanup old data points\r\n-    final oldData = await userCollection\r\n-        .doc(componentId)\r\n-        .collection('parameters')\r\n-        .doc(parameterName)\r\n-        .collection('history')\r\n-        .orderBy('timestamp', descending: true)\r\n-        .limit(MAX_HISTORY_POINTS + 1)\r\n-        .get();\r\n-\r\n-    if (oldData.docs.length > MAX_HISTORY_POINTS) {\r\n-      final batch = FirebaseFirestore.instance.batch();\r\n-      oldData.docs\r\n-          .sublist(MAX_HISTORY_POINTS)\r\n-          .forEach((doc) => batch.delete(doc.reference));\r\n-      await batch.commit();\r\n-    }\r\n-  }\r\n-\r\n-  Stream<List<DataPoint>> watchParameterHistory(\r\n-    String componentId,\r\n-    String parameterName,\r\n-    Duration duration,\r\n-  ) {\r\n-    final cutoff = DateTime.now().subtract(duration);\r\n-\r\n-    return userCollection\r\n-        .doc(componentId)\r\n-        .collection('parameters')\r\n-        .doc(parameterName)\r\n-        .collection('history')\r\n-        .where('timestamp', isGreaterThan: cutoff.millisecondsSinceEpoch)\r\n-        .orderBy('timestamp', descending: true)\r\n-        .limit(MAX_HISTORY_POINTS)\r\n-        .snapshots()\r\n-        .map((snapshot) => snapshot.docs\r\n-            .map((doc) => DataPoint.fromJson(doc.data()))\r\n-            .toList());\r\n-  }\r\n-\r\n-  Future<void> saveThresholds(\r\n-    String componentId,\r\n-    String parameterName,\r\n-    double minValue,\r\n-    double maxValue,\r\n-  ) async {\r\n-    await save('thresholds/$componentId/$parameterName', {\r\n-      'min': minValue,\r\n-      'max': maxValue,\r\n-      'updatedAt': FieldValue.serverTimestamp(),\r\n-    });\r\n-  }\r\n-\r\n-  Future<Map<String, Map<String, double>>> getThresholds(String componentId) async {\r\n-    final doc = await get('thresholds/$componentId');\r\n-    if (doc == null) return {};\r\n-\r\n-    final thresholds = <String, Map<String, double>>{};\r\n-    doc.forEach((parameter, value) {\r\n-      if (value is Map) {\r\n-        thresholds[parameter] = {\r\n-          'min': (value['min'] as num).toDouble(),\r\n-          'max': (value['max'] as num).toDouble(),\r\n-        };\r\n-      }\r\n-    });\r\n-    return thresholds;\r\n-  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734455944827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,26 @@\n-\r\n import 'package:cloud_firestore/cloud_firestore.dart';\r\n+import 'package:experiment_planner/shared/base/base_repository.dart';\r\n import '../../components/models/data_point.dart';\r\n \r\n-class ParameterMonitoringRepository extends BlocRepository<Map<String, dynamic>> {\r\n+class ParameterMonitoringRepository extends BaseRepository<Map<String, dynamic>> {\r\n   static const int MAX_HISTORY_POINTS = 1000;\r\n+  final FirebaseFirestore _firestore;\r\n \r\n-  ParameterMonitoringRepository({String? userId}) : super(\r\n-    collectionName: 'parameter_monitoring',\r\n-    userId: userId,\r\n-  );\r\n+  ParameterMonitoringRepository({String? userId}) :\r\n+    _firestore = FirebaseFirestore.instance,\r\n+    super('parameter_monitoring');\r\n \r\n   @override\r\n   Map<String, dynamic> fromJson(Map<String, dynamic> json) => json;\r\n \r\n-  @override\r\n-  Map<String, dynamic> toJson(Map<String, dynamic> data) => data;\r\n-\r\n   Future<void> saveParameterValue(\r\n     String componentId,\r\n     String parameterName,\r\n     DataPoint dataPoint,\r\n+    {required String userId}\r\n   ) async {\r\n-    final docRef = userCollection\r\n+    final docRef = getUserCollection(userId)\r\n         .doc(componentId)\r\n         .collection('parameters')\r\n         .doc(parameterName)\r\n         .collection('history')\r\n@@ -30,9 +28,9 @@\n \r\n     await docRef.set(dataPoint.toJson());\r\n \r\n     // Cleanup old data points\r\n-    final oldData = await userCollection\r\n+    final oldData = await getUserCollection(userId)\r\n         .doc(componentId)\r\n         .collection('parameters')\r\n         .doc(parameterName)\r\n         .collection('history')\r\n@@ -40,9 +38,9 @@\n         .limit(MAX_HISTORY_POINTS + 1)\r\n         .get();\r\n \r\n     if (oldData.docs.length > MAX_HISTORY_POINTS) {\r\n-      final batch = FirebaseFirestore.instance.batch();\r\n+      final batch = _firestore.batch();\r\n       oldData.docs\r\n           .sublist(MAX_HISTORY_POINTS)\r\n           .forEach((doc) => batch.delete(doc.reference));\r\n       await batch.commit();\r\n@@ -52,12 +50,13 @@\n   Stream<List<DataPoint>> watchParameterHistory(\r\n     String componentId,\r\n     String parameterName,\r\n     Duration duration,\r\n+    {required String userId}\r\n   ) {\r\n     final cutoff = DateTime.now().subtract(duration);\r\n \r\n-    return userCollection\r\n+    return getUserCollection(userId)\r\n         .doc(componentId)\r\n         .collection('parameters')\r\n         .doc(parameterName)\r\n         .collection('history')\r\n@@ -74,18 +73,26 @@\n     String componentId,\r\n     String parameterName,\r\n     double minValue,\r\n     double maxValue,\r\n+    {required String userId}\r\n   ) async {\r\n-    await save('thresholds/$componentId/$parameterName', {\r\n-      'min': minValue,\r\n-      'max': maxValue,\r\n-      'updatedAt': FieldValue.serverTimestamp(),\r\n-    });\r\n+    await add(\r\n+      'thresholds/$componentId/$parameterName',\r\n+      {\r\n+        'min': minValue,\r\n+        'max': maxValue,\r\n+        'updatedAt': FieldValue.serverTimestamp(),\r\n+      },\r\n+      userId: userId\r\n+    );\r\n   }\r\n \r\n-  Future<Map<String, Map<String, double>>> getThresholds(String componentId) async {\r\n-    final doc = await get('thresholds/$componentId');\r\n+  Future<Map<String, Map<String, double>>> getThresholds(\r\n+    String componentId,\r\n+    {required String userId}\r\n+  ) async {\r\n+    final doc = await get('thresholds/$componentId', userId: userId);\r\n     if (doc == null) return {};\r\n \r\n     final thresholds = <String, Map<String, double>>{};\r\n     doc.forEach((parameter, value) {\r\n"
                }
            ],
            "date": 1734376760298,
            "name": "Commit-0",
            "content": "\r\nimport 'package:cloud_firestore/cloud_firestore.dart';\r\nimport '../../components/models/data_point.dart';\r\nimport '../../../base/base_repository.dart';\r\n\r\nclass ParameterMonitoringRepository extends BlocRepository<Map<String, dynamic>> {\r\n  static const int MAX_HISTORY_POINTS = 1000;\r\n\r\n  ParameterMonitoringRepository({String? userId}) : super(\r\n    collectionName: 'parameter_monitoring',\r\n    userId: userId,\r\n  );\r\n\r\n  @override\r\n  Map<String, dynamic> fromJson(Map<String, dynamic> json) => json;\r\n\r\n  @override\r\n  Map<String, dynamic> toJson(Map<String, dynamic> data) => data;\r\n\r\n  Future<void> saveParameterValue(\r\n    String componentId,\r\n    String parameterName,\r\n    DataPoint dataPoint,\r\n  ) async {\r\n    final docRef = userCollection\r\n        .doc(componentId)\r\n        .collection('parameters')\r\n        .doc(parameterName)\r\n        .collection('history')\r\n        .doc(dataPoint.timestamp.millisecondsSinceEpoch.toString());\r\n\r\n    await docRef.set(dataPoint.toJson());\r\n\r\n    // Cleanup old data points\r\n    final oldData = await userCollection\r\n        .doc(componentId)\r\n        .collection('parameters')\r\n        .doc(parameterName)\r\n        .collection('history')\r\n        .orderBy('timestamp', descending: true)\r\n        .limit(MAX_HISTORY_POINTS + 1)\r\n        .get();\r\n\r\n    if (oldData.docs.length > MAX_HISTORY_POINTS) {\r\n      final batch = FirebaseFirestore.instance.batch();\r\n      oldData.docs\r\n          .sublist(MAX_HISTORY_POINTS)\r\n          .forEach((doc) => batch.delete(doc.reference));\r\n      await batch.commit();\r\n    }\r\n  }\r\n\r\n  Stream<List<DataPoint>> watchParameterHistory(\r\n    String componentId,\r\n    String parameterName,\r\n    Duration duration,\r\n  ) {\r\n    final cutoff = DateTime.now().subtract(duration);\r\n\r\n    return userCollection\r\n        .doc(componentId)\r\n        .collection('parameters')\r\n        .doc(parameterName)\r\n        .collection('history')\r\n        .where('timestamp', isGreaterThan: cutoff.millisecondsSinceEpoch)\r\n        .orderBy('timestamp', descending: true)\r\n        .limit(MAX_HISTORY_POINTS)\r\n        .snapshots()\r\n        .map((snapshot) => snapshot.docs\r\n            .map((doc) => DataPoint.fromJson(doc.data()))\r\n            .toList());\r\n  }\r\n\r\n  Future<void> saveThresholds(\r\n    String componentId,\r\n    String parameterName,\r\n    double minValue,\r\n    double maxValue,\r\n  ) async {\r\n    await save('thresholds/$componentId/$parameterName', {\r\n      'min': minValue,\r\n      'max': maxValue,\r\n      'updatedAt': FieldValue.serverTimestamp(),\r\n    });\r\n  }\r\n\r\n  Future<Map<String, Map<String, double>>> getThresholds(String componentId) async {\r\n    final doc = await get('thresholds/$componentId');\r\n    if (doc == null) return {};\r\n\r\n    final thresholds = <String, Map<String, double>>{};\r\n    doc.forEach((parameter, value) {\r\n      if (value is Map) {\r\n        thresholds[parameter] = {\r\n          'min': (value['min'] as num).toDouble(),\r\n          'max': (value['max'] as num).toDouble(),\r\n        };\r\n      }\r\n    });\r\n    return thresholds;\r\n  }\r\n}"
        }
    ]
}