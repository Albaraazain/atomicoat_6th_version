{
    "sourceFile": "lib/features/monitoring/repository/parameter_monitoring_repository.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1734376760298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1734376760298,
            "name": "Commit-0",
            "content": "\r\nimport 'package:cloud_firestore/cloud_firestore.dart';\r\nimport '../../components/models/data_point.dart';\r\nimport '../../../base/base_repository.dart';\r\n\r\nclass ParameterMonitoringRepository extends BlocRepository<Map<String, dynamic>> {\r\n  static const int MAX_HISTORY_POINTS = 1000;\r\n\r\n  ParameterMonitoringRepository({String? userId}) : super(\r\n    collectionName: 'parameter_monitoring',\r\n    userId: userId,\r\n  );\r\n\r\n  @override\r\n  Map<String, dynamic> fromJson(Map<String, dynamic> json) => json;\r\n\r\n  @override\r\n  Map<String, dynamic> toJson(Map<String, dynamic> data) => data;\r\n\r\n  Future<void> saveParameterValue(\r\n    String componentId,\r\n    String parameterName,\r\n    DataPoint dataPoint,\r\n  ) async {\r\n    final docRef = userCollection\r\n        .doc(componentId)\r\n        .collection('parameters')\r\n        .doc(parameterName)\r\n        .collection('history')\r\n        .doc(dataPoint.timestamp.millisecondsSinceEpoch.toString());\r\n\r\n    await docRef.set(dataPoint.toJson());\r\n\r\n    // Cleanup old data points\r\n    final oldData = await userCollection\r\n        .doc(componentId)\r\n        .collection('parameters')\r\n        .doc(parameterName)\r\n        .collection('history')\r\n        .orderBy('timestamp', descending: true)\r\n        .limit(MAX_HISTORY_POINTS + 1)\r\n        .get();\r\n\r\n    if (oldData.docs.length > MAX_HISTORY_POINTS) {\r\n      final batch = FirebaseFirestore.instance.batch();\r\n      oldData.docs\r\n          .sublist(MAX_HISTORY_POINTS)\r\n          .forEach((doc) => batch.delete(doc.reference));\r\n      await batch.commit();\r\n    }\r\n  }\r\n\r\n  Stream<List<DataPoint>> watchParameterHistory(\r\n    String componentId,\r\n    String parameterName,\r\n    Duration duration,\r\n  ) {\r\n    final cutoff = DateTime.now().subtract(duration);\r\n\r\n    return userCollection\r\n        .doc(componentId)\r\n        .collection('parameters')\r\n        .doc(parameterName)\r\n        .collection('history')\r\n        .where('timestamp', isGreaterThan: cutoff.millisecondsSinceEpoch)\r\n        .orderBy('timestamp', descending: true)\r\n        .limit(MAX_HISTORY_POINTS)\r\n        .snapshots()\r\n        .map((snapshot) => snapshot.docs\r\n            .map((doc) => DataPoint.fromJson(doc.data()))\r\n            .toList());\r\n  }\r\n\r\n  Future<void> saveThresholds(\r\n    String componentId,\r\n    String parameterName,\r\n    double minValue,\r\n    double maxValue,\r\n  ) async {\r\n    await save('thresholds/$componentId/$parameterName', {\r\n      'min': minValue,\r\n      'max': maxValue,\r\n      'updatedAt': FieldValue.serverTimestamp(),\r\n    });\r\n  }\r\n\r\n  Future<Map<String, Map<String, double>>> getThresholds(String componentId) async {\r\n    final doc = await get('thresholds/$componentId');\r\n    if (doc == null) return {};\r\n\r\n    final thresholds = <String, Map<String, double>>{};\r\n    doc.forEach((parameter, value) {\r\n      if (value is Map) {\r\n        thresholds[parameter] = {\r\n          'min': (value['min'] as num).toDouble(),\r\n          'max': (value['max'] as num).toDouble(),\r\n        };\r\n      }\r\n    });\r\n    return thresholds;\r\n  }\r\n}"
        }
    ]
}