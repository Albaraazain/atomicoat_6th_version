{
    "sourceFile": "lib/features/components/repository/component_repository.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1734376760285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1734429592203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,8 @@\n \r\n import 'package:cloud_firestore/cloud_firestore.dart';\r\n import 'package:experiment_planner/core/exceptions/bloc_exception.dart';\r\n import '../models/system_component.dart';\r\n-import '../../auth/services/auth_service.dart';\r\n import '../../../core/utils/data_point_cache.dart';\r\n \r\n class ComponentRepository {\r\n   final FirebaseFirestore _firestore;\r\n"
                },
                {
                    "date": 1734456764080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,135 +1,79 @@\n-\r\n-\r\n import 'package:cloud_firestore/cloud_firestore.dart';\r\n-import 'package:experiment_planner/core/exceptions/bloc_exception.dart';\r\n+import 'package:experiment_planner/shared/base/base_repository.dart';\r\n import '../models/system_component.dart';\r\n-import '../../../core/utils/data_point_cache.dart';\r\n+import '../../../core/exceptions/bloc_exception.dart';\r\n \r\n-class ComponentRepository {\r\n-  final FirebaseFirestore _firestore;\r\n+class UserComponentStateRepository extends BaseRepository<SystemComponent> {\r\n+  static const String HISTORY_LIMIT = 1000;\r\n \r\n-  ComponentRepository()\r\n-      : _firestore = FirebaseFirestore.instance;\r\n+  UserComponentStateRepository() : super('component_states');\r\n \r\n-  CollectionReference get componentsCollection =>\r\n-      _firestore.collection('system_components');\r\n+  @override\r\n+  SystemComponent fromJson(Map<String, dynamic> json) =>\r\n+      SystemComponent.fromJson(json);\r\n \r\n-  Future<SystemComponent?> getComponent(String name) async {\r\n+  Future<void> saveComponentState(\r\n+    SystemComponent component,\r\n+    {required String userId}\r\n+  ) async {\r\n     try {\r\n-      final doc = await componentsCollection.doc(name).get();\r\n-      if (!doc.exists) return null;\r\n-      return SystemComponent.fromJson({\r\n-        ...doc.data() as Map<String, dynamic>,\r\n-        'name': doc.id,\r\n-      });\r\n-    } catch (e) {\r\n-      throw BlocException('Failed to get component: ${e.toString()}');\r\n-    }\r\n-  }\r\n-\r\n-  Stream<List<SystemComponent>> watchAllComponents() {\r\n-    return componentsCollection.snapshots().map((snapshot) {\r\n-      try {\r\n-        return snapshot.docs.map((doc) {\r\n-          return SystemComponent.fromJson({\r\n-            ...doc.data() as Map<String, dynamic>,\r\n-            'name': doc.id,\r\n-          });\r\n-        }).toList();\r\n-      } catch (e) {\r\n-        throw BlocException('Failed to process components update: ${e.toString()}');\r\n-      }\r\n-    });\r\n-  }\r\n-\r\n-  Future<List<SystemComponent>> getAllComponents() async {\r\n-    try {\r\n-      final snapshot = await componentsCollection.get();\r\n-      return snapshot.docs.map((doc) {\r\n-        return SystemComponent.fromJson({\r\n-          ...doc.data() as Map<String, dynamic>,\r\n-          'name': doc.id,\r\n-        });\r\n-      }).toList();\r\n-    } catch (e) {\r\n-      throw BlocException('Failed to get all components: ${e.toString()}');\r\n-    }\r\n-  }\r\n-\r\n-  Stream<SystemComponent?> watchComponent(String componentName) {\r\n-    return componentsCollection\r\n-        .doc(componentName)\r\n-        .snapshots()\r\n-        .map((snapshot) {\r\n-          try {\r\n-            if (!snapshot.exists) return null;\r\n-\r\n-            return SystemComponent.fromJson({\r\n-              ...snapshot.data() as Map<String, dynamic>,\r\n-              'name': snapshot.id,\r\n-            });\r\n-          } catch (e) {\r\n-            throw BlocException('Failed to process component update: ${e.toString()}');\r\n-          }\r\n-        });\r\n-  }\r\n-\r\n-  Future<void> saveComponentState(SystemComponent component) async {\r\n-    try {\r\n-      // Validate component before saving\r\n       _validateComponent(component);\r\n+      await add(component.name, component, userId: userId);\r\n \r\n-      // Save to Firestore\r\n-      await componentsCollection.doc(component.name).set(\r\n-        component.toJson(),\r\n-        SetOptions(merge: true),\r\n-      );\r\n+      // Save historical data\r\n+      await getUserCollection(userId)\r\n+          .doc(component.name)\r\n+          .collection('history')\r\n+          .add({\r\n+        'timestamp': FieldValue.serverTimestamp(),\r\n+        'currentValues': component.currentValues,\r\n+        'setValues': component.setValues,\r\n+        'isActivated': component.isActivated,\r\n+      });\r\n     } catch (e) {\r\n       throw BlocException('Failed to save component state: ${e.toString()}');\r\n     }\r\n   }\r\n \r\n   Future<void> updateComponentValues(\r\n     String componentName,\r\n     Map<String, double> values,\r\n+    {required String userId}\r\n   ) async {\r\n     try {\r\n-      final component = await getComponent(componentName);\r\n-      if (component == null) {\r\n-        throw BlocException('Component not found: $componentName');\r\n+      final doc = await getUserCollection(userId).doc(componentName).get();\r\n+      if (!doc.exists) {\r\n+        throw BlocException('Component state not found: $componentName');\r\n       }\r\n \r\n+      final component = fromJson(doc.data() as Map<String, dynamic>);\r\n       component.updateCurrentValues(values);\r\n-      await saveComponentState(component);\r\n+      await saveComponentState(component, userId: userId);\r\n     } catch (e) {\r\n       throw BlocException('Failed to update component values: ${e.toString()}');\r\n     }\r\n   }\r\n \r\n-  Future<void> updateComponentSetValues(\r\n-    String componentName,\r\n-    Map<String, double> setValues,\r\n-  ) async {\r\n+  Future<List<SystemComponent>> getActiveComponents(String userId) async {\r\n     try {\r\n-      final component = await getComponent(componentName);\r\n-      if (component == null) {\r\n-        throw BlocException('Component not found: $componentName');\r\n-      }\r\n+      final snapshot = await getUserCollection(userId)\r\n+          .where('isActivated', isEqualTo: true)\r\n+          .get();\r\n \r\n-      component.updateSetValues(setValues);\r\n-      await saveComponentState(component);\r\n+      return snapshot.docs\r\n+          .map((doc) => fromJson(doc.data() as Map<String, dynamic>))\r\n+          .toList();\r\n     } catch (e) {\r\n-      throw BlocException('Failed to update component set values: ${e.toString()}');\r\n+      throw BlocException('Failed to get active components: ${e.toString()}');\r\n     }\r\n   }\r\n \r\n   void _validateComponent(SystemComponent component) {\r\n     if (component.name.isEmpty) {\r\n       throw BlocException('Component name cannot be empty');\r\n     }\r\n \r\n-    // Validate current values against min/max\r\n     for (final entry in component.currentValues.entries) {\r\n       final parameter = entry.key;\r\n       final value = entry.value;\r\n \r\n@@ -147,17 +91,5 @@\n         );\r\n       }\r\n     }\r\n   }\r\n-\r\n-  Future<void> clearComponentErrors(String componentName) async {\r\n-    try {\r\n-      final component = await getComponent(componentName);\r\n-      if (component == null) return;\r\n-\r\n-      component.clearErrorMessages();\r\n-      await saveComponentState(component);\r\n-    } catch (e) {\r\n-      throw BlocException('Failed to clear component errors: ${e.toString()}');\r\n-    }\r\n-  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734456775746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n import '../models/system_component.dart';\r\n import '../../../core/exceptions/bloc_exception.dart';\r\n \r\n class UserComponentStateRepository extends BaseRepository<SystemComponent> {\r\n-  static const String HISTORY_LIMIT = 1000;\r\n+  static const int HISTORY_LIMIT = 1000;\r\n \r\n   UserComponentStateRepository() : super('component_states');\r\n \r\n   @override\r\n"
                }
            ],
            "date": 1734376760285,
            "name": "Commit-0",
            "content": "\r\n\r\nimport 'package:cloud_firestore/cloud_firestore.dart';\r\nimport 'package:experiment_planner/core/exceptions/bloc_exception.dart';\r\nimport '../models/system_component.dart';\r\nimport '../../auth/services/auth_service.dart';\r\nimport '../../../core/utils/data_point_cache.dart';\r\n\r\nclass ComponentRepository {\r\n  final FirebaseFirestore _firestore;\r\n\r\n  ComponentRepository()\r\n      : _firestore = FirebaseFirestore.instance;\r\n\r\n  CollectionReference get componentsCollection =>\r\n      _firestore.collection('system_components');\r\n\r\n  Future<SystemComponent?> getComponent(String name) async {\r\n    try {\r\n      final doc = await componentsCollection.doc(name).get();\r\n      if (!doc.exists) return null;\r\n      return SystemComponent.fromJson({\r\n        ...doc.data() as Map<String, dynamic>,\r\n        'name': doc.id,\r\n      });\r\n    } catch (e) {\r\n      throw BlocException('Failed to get component: ${e.toString()}');\r\n    }\r\n  }\r\n\r\n  Stream<List<SystemComponent>> watchAllComponents() {\r\n    return componentsCollection.snapshots().map((snapshot) {\r\n      try {\r\n        return snapshot.docs.map((doc) {\r\n          return SystemComponent.fromJson({\r\n            ...doc.data() as Map<String, dynamic>,\r\n            'name': doc.id,\r\n          });\r\n        }).toList();\r\n      } catch (e) {\r\n        throw BlocException('Failed to process components update: ${e.toString()}');\r\n      }\r\n    });\r\n  }\r\n\r\n  Future<List<SystemComponent>> getAllComponents() async {\r\n    try {\r\n      final snapshot = await componentsCollection.get();\r\n      return snapshot.docs.map((doc) {\r\n        return SystemComponent.fromJson({\r\n          ...doc.data() as Map<String, dynamic>,\r\n          'name': doc.id,\r\n        });\r\n      }).toList();\r\n    } catch (e) {\r\n      throw BlocException('Failed to get all components: ${e.toString()}');\r\n    }\r\n  }\r\n\r\n  Stream<SystemComponent?> watchComponent(String componentName) {\r\n    return componentsCollection\r\n        .doc(componentName)\r\n        .snapshots()\r\n        .map((snapshot) {\r\n          try {\r\n            if (!snapshot.exists) return null;\r\n\r\n            return SystemComponent.fromJson({\r\n              ...snapshot.data() as Map<String, dynamic>,\r\n              'name': snapshot.id,\r\n            });\r\n          } catch (e) {\r\n            throw BlocException('Failed to process component update: ${e.toString()}');\r\n          }\r\n        });\r\n  }\r\n\r\n  Future<void> saveComponentState(SystemComponent component) async {\r\n    try {\r\n      // Validate component before saving\r\n      _validateComponent(component);\r\n\r\n      // Save to Firestore\r\n      await componentsCollection.doc(component.name).set(\r\n        component.toJson(),\r\n        SetOptions(merge: true),\r\n      );\r\n    } catch (e) {\r\n      throw BlocException('Failed to save component state: ${e.toString()}');\r\n    }\r\n  }\r\n\r\n  Future<void> updateComponentValues(\r\n    String componentName,\r\n    Map<String, double> values,\r\n  ) async {\r\n    try {\r\n      final component = await getComponent(componentName);\r\n      if (component == null) {\r\n        throw BlocException('Component not found: $componentName');\r\n      }\r\n\r\n      component.updateCurrentValues(values);\r\n      await saveComponentState(component);\r\n    } catch (e) {\r\n      throw BlocException('Failed to update component values: ${e.toString()}');\r\n    }\r\n  }\r\n\r\n  Future<void> updateComponentSetValues(\r\n    String componentName,\r\n    Map<String, double> setValues,\r\n  ) async {\r\n    try {\r\n      final component = await getComponent(componentName);\r\n      if (component == null) {\r\n        throw BlocException('Component not found: $componentName');\r\n      }\r\n\r\n      component.updateSetValues(setValues);\r\n      await saveComponentState(component);\r\n    } catch (e) {\r\n      throw BlocException('Failed to update component set values: ${e.toString()}');\r\n    }\r\n  }\r\n\r\n  void _validateComponent(SystemComponent component) {\r\n    if (component.name.isEmpty) {\r\n      throw BlocException('Component name cannot be empty');\r\n    }\r\n\r\n    // Validate current values against min/max\r\n    for (final entry in component.currentValues.entries) {\r\n      final parameter = entry.key;\r\n      final value = entry.value;\r\n\r\n      if (component.minValues.containsKey(parameter) &&\r\n          value < component.minValues[parameter]!) {\r\n        throw BlocException(\r\n          'Value for $parameter is below minimum: $value < ${component.minValues[parameter]}',\r\n        );\r\n      }\r\n\r\n      if (component.maxValues.containsKey(parameter) &&\r\n          value > component.maxValues[parameter]!) {\r\n        throw BlocException(\r\n          'Value for $parameter is above maximum: $value > ${component.maxValues[parameter]}',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  Future<void> clearComponentErrors(String componentName) async {\r\n    try {\r\n      final component = await getComponent(componentName);\r\n      if (component == null) return;\r\n\r\n      component.clearErrorMessages();\r\n      await saveComponentState(component);\r\n    } catch (e) {\r\n      throw BlocException('Failed to clear component errors: ${e.toString()}');\r\n    }\r\n  }\r\n}"
        }
    ]
}