{
    "sourceFile": "lib/features/recipes/repository/recipe_repository.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1734376760281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1734377249345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-\r\n-\r\n import 'package:cloud_firestore/cloud_firestore.dart';\r\n import 'package:experiment_planner/core/exceptions/bloc_exception.dart';\r\n import 'package:experiment_planner/features/recipes/models/recipe.dart';\r\n \r\n@@ -10,14 +8,41 @@\n \r\n   RecipeRepository({FirebaseFirestore? firestore})\r\n       : _firestore = firestore ?? FirebaseFirestore.instance;\r\n \r\n-  // Get all recipes for a user\r\n-  Future<List<Recipe>> getAll({required String userId}) async {\r\n+  // Add this new method after the constructor\r\n+  Stream<List<Recipe>> watchUserRecipes(String userId) {\r\n+    return _firestore\r\n+        .collection(_collection)\r\n+        .where('userId', isEqualTo: userId)\r\n+        .orderBy('lastModified', descending: true)\r\n+        .snapshots()\r\n+        .map((snapshot) => snapshot.docs\r\n+            .map((doc) => Recipe.fromJson(doc.data()))\r\n+            .toList());\r\n+  }\r\n+\r\n+  // Replace existing getAll method\r\n+  Future<List<Recipe>> getAll({\r\n+    required String userId,\r\n+    String? substrate,\r\n+    DateTime? modifiedAfter,\r\n+  }) async {\r\n     try {\r\n-      final querySnapshot = await _firestore\r\n+      Query query = _firestore\r\n           .collection(_collection)\r\n-          .where('userId', isEqualTo: userId)\r\n+          .where('userId', isEqualTo: userId);\r\n+\r\n+      if (substrate != null) {\r\n+        query = query.where('substrate', isEqualTo: substrate);\r\n+      }\r\n+\r\n+      if (modifiedAfter != null) {\r\n+        query = query.where('lastModified',\r\n+            isGreaterThan: Timestamp.fromDate(modifiedAfter));\r\n+      }\r\n+\r\n+      final querySnapshot = await query\r\n           .orderBy('lastModified', descending: true)\r\n           .get();\r\n \r\n       return querySnapshot.docs\r\n"
                },
                {
                    "date": 1734377298439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n           .orderBy('lastModified', descending: true)\r\n           .get();\r\n \r\n       return querySnapshot.docs\r\n-          .map((doc) => Recipe.fromJson(doc.data()))\r\n+          .map((doc) => Recipe.fromJson(doc.data() as Map<String, dynamic>))\r\n           .toList();\r\n     } catch (e) {\r\n       throw BlocException(\r\n         'Failed to fetch recipes: ${e.toString()}',\r\n"
                },
                {
                    "date": 1734456668070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,37 +1,31 @@\n import 'package:cloud_firestore/cloud_firestore.dart';\r\n import 'package:experiment_planner/core/exceptions/bloc_exception.dart';\r\n+import 'package:experiment_planner/shared/base/base_repository.dart';\r\n import 'package:experiment_planner/features/recipes/models/recipe.dart';\r\n \r\n-class RecipeRepository {\r\n-  final FirebaseFirestore _firestore;\r\n-  static const String _collection = 'recipes';\r\n+class RecipeRepository extends BaseRepository<Recipe> {\r\n+  RecipeRepository() : super('recipes');\r\n \r\n-  RecipeRepository({FirebaseFirestore? firestore})\r\n-      : _firestore = firestore ?? FirebaseFirestore.instance;\r\n+  @override\r\n+  Recipe fromJson(Map<String, dynamic> json) => Recipe.fromJson(json);\r\n \r\n-  // Add this new method after the constructor\r\n   Stream<List<Recipe>> watchUserRecipes(String userId) {\r\n-    return _firestore\r\n-        .collection(_collection)\r\n-        .where('userId', isEqualTo: userId)\r\n+    return getUserCollection(userId)\r\n         .orderBy('lastModified', descending: true)\r\n         .snapshots()\r\n         .map((snapshot) => snapshot.docs\r\n-            .map((doc) => Recipe.fromJson(doc.data()))\r\n+            .map((doc) => fromJson(doc.data() as Map<String, dynamic>))\r\n             .toList());\r\n   }\r\n \r\n-  // Replace existing getAll method\r\n-  Future<List<Recipe>> getAll({\r\n+  Future<List<Recipe>> getByFilters({\r\n     required String userId,\r\n     String? substrate,\r\n     DateTime? modifiedAfter,\r\n   }) async {\r\n     try {\r\n-      Query query = _firestore\r\n-          .collection(_collection)\r\n-          .where('userId', isEqualTo: userId);\r\n+      var query = getUserCollection(userId).orderBy('lastModified', descending: true);\r\n \r\n       if (substrate != null) {\r\n         query = query.where('substrate', isEqualTo: substrate);\r\n       }\r\n@@ -40,171 +34,88 @@\n         query = query.where('lastModified',\r\n             isGreaterThan: Timestamp.fromDate(modifiedAfter));\r\n       }\r\n \r\n-      final querySnapshot = await query\r\n-          .orderBy('lastModified', descending: true)\r\n-          .get();\r\n+      final querySnapshot = await query.get();\r\n \r\n       return querySnapshot.docs\r\n-          .map((doc) => Recipe.fromJson(doc.data() as Map<String, dynamic>))\r\n+          .map((doc) => fromJson(doc.data() as Map<String, dynamic>))\r\n           .toList();\r\n     } catch (e) {\r\n       throw BlocException(\r\n         'Failed to fetch recipes: ${e.toString()}',\r\n       );\r\n     }\r\n   }\r\n \r\n-  // Add a new recipe\r\n+  @override\r\n   Future<void> add(String id, Recipe recipe, {required String userId}) async {\r\n     try {\r\n       final data = recipe.toJson();\r\n-      data['userId'] = userId;\r\n-\r\n-      await _firestore.collection(_collection).doc(id).set(data);\r\n+      await super.add(id, recipe, userId: userId);\r\n     } catch (e) {\r\n       throw BlocException(\r\n         'Failed to add recipe: ${e.toString()}',\r\n       );\r\n     }\r\n   }\r\n \r\n-  // Update an existing recipe\r\n-  Future<void> update(String id, Recipe recipe,\r\n-      {required String userId}) async {\r\n+  Future<void> duplicate(\r\n+    String sourceId,\r\n+    String newId,\r\n+    String newName,\r\n+    {required String userId}\r\n+  ) async {\r\n     try {\r\n-      final docRef = _firestore.collection(_collection).doc(id);\r\n-      final doc = await docRef.get();\r\n-\r\n-      if (!doc.exists) {\r\n-        throw BlocException('Recipe not found');\r\n+      final sourceRecipe = await get(sourceId, userId: userId);\r\n+      if (sourceRecipe == null) {\r\n+        throw BlocException('Source recipe not found');\r\n       }\r\n \r\n-      final existingData = doc.data();\r\n-      if (existingData?['userId'] != userId) {\r\n-        throw BlocException('Unauthorized to update this recipe');\r\n-      }\r\n-\r\n-      final data = recipe.toJson();\r\n-      data['userId'] = userId;\r\n-      data['lastModified'] = Timestamp.now();\r\n-\r\n-      await docRef.update(data);\r\n-    } catch (e) {\r\n-      throw BlocException(\r\n-        'Failed to update recipe: ${e.toString()}',\r\n+      final newRecipe = sourceRecipe.copyWith(\r\n+        id: newId,\r\n+        name: newName,\r\n+        version: 1,\r\n+        lastModified: DateTime.now(),\r\n       );\r\n-    }\r\n-  }\r\n \r\n-  // Delete a recipe\r\n-  Future<void> delete(String id, {required String userId}) async {\r\n-    try {\r\n-      final docRef = _firestore.collection(_collection).doc(id);\r\n-      final doc = await docRef.get();\r\n-\r\n-      if (!doc.exists) {\r\n-        throw BlocException('Recipe not found');\r\n-      }\r\n-\r\n-      final data = doc.data();\r\n-      if (data?['userId'] != userId) {\r\n-        throw BlocException('Unauthorized to delete this recipe');\r\n-      }\r\n-\r\n-      await docRef.delete();\r\n+      await add(newId, newRecipe, userId: userId);\r\n     } catch (e) {\r\n       throw BlocException(\r\n-        'Failed to delete recipe: ${e.toString()}',\r\n+        'Failed to duplicate recipe: ${e.toString()}',\r\n       );\r\n     }\r\n   }\r\n \r\n-  // Get a specific recipe by ID\r\n-  Future<Recipe?> getById(String id, {required String userId}) async {\r\n-    try {\r\n-      final docSnapshot =\r\n-          await _firestore.collection(_collection).doc(id).get();\r\n+  Stream<Recipe> watchRecipe(String id, {required String userId}) {\r\n+    return getUserCollection(userId)\r\n+        .doc(id)\r\n+        .snapshots()\r\n+        .map((snapshot) {\r\n+          if (!snapshot.exists) {\r\n+            throw BlocException('Recipe not found');\r\n+          }\r\n \r\n-      if (!docSnapshot.exists) {\r\n-        return null;\r\n-      }\r\n-\r\n-      final data = docSnapshot.data()!;\r\n-      if (data['userId'] != userId) {\r\n-        throw BlocException('Unauthorized to access this recipe');\r\n-      }\r\n-\r\n-      return Recipe.fromJson(data);\r\n-    } catch (e) {\r\n-      throw BlocException(\r\n-        'Failed to fetch recipe: ${e.toString()}',\r\n-      );\r\n-    }\r\n+          return fromJson(snapshot.data() as Map<String, dynamic>);\r\n+        });\r\n   }\r\n \r\n-  // Get recipes by substrate type\r\n-  Future<List<Recipe>> getBySubstrate(String substrate,\r\n-      {required String userId}) async {\r\n+  Future<List<Recipe>> getBySubstrate(\r\n+    String substrate,\r\n+    {required String userId}\r\n+  ) async {\r\n     try {\r\n-      final querySnapshot = await _firestore\r\n-          .collection(_collection)\r\n-          .where('userId', isEqualTo: userId)\r\n+      final snapshot = await getUserCollection(userId)\r\n           .where('substrate', isEqualTo: substrate)\r\n           .orderBy('lastModified', descending: true)\r\n           .get();\r\n \r\n-      return querySnapshot.docs\r\n-          .map((doc) => Recipe.fromJson(doc.data()))\r\n+      return snapshot.docs\r\n+          .map((doc) => fromJson(doc.data() as Map<String, dynamic>))\r\n           .toList();\r\n     } catch (e) {\r\n       throw BlocException(\r\n         'Failed to fetch recipes by substrate: ${e.toString()}',\r\n       );\r\n     }\r\n   }\r\n-\r\n-  // Stream of recipe updates\r\n-  Stream<Recipe> watchRecipe(String id, {required String userId}) {\r\n-    return _firestore\r\n-        .collection(_collection)\r\n-        .doc(id)\r\n-        .snapshots()\r\n-        .map((snapshot) {\r\n-      if (!snapshot.exists) {\r\n-        throw BlocException('Recipe not found');\r\n-      }\r\n-\r\n-      final data = snapshot.data()!;\r\n-      if (data['userId'] != userId) {\r\n-        throw BlocException('Unauthorized to access this recipe');\r\n-      }\r\n-\r\n-      return Recipe.fromJson(data);\r\n-    });\r\n-  }\r\n-\r\n-  // Duplicate a recipe\r\n-  Future<void> duplicate(String sourceId, String newId, String newName,\r\n-      {required String userId}) async {\r\n-    try {\r\n-      final sourceRecipe = await getById(sourceId, userId: userId);\r\n-      if (sourceRecipe == null) {\r\n-        throw BlocException('Source recipe not found');\r\n-      }\r\n-\r\n-      final newRecipe = sourceRecipe.copyWith(\r\n-        id: newId,\r\n-        name: newName,\r\n-        version: 1,\r\n-        lastModified: DateTime.now(),\r\n-      );\r\n-\r\n-      await add(newId, newRecipe, userId: userId);\r\n-    } catch (e) {\r\n-      throw BlocException(\r\n-        'Failed to duplicate recipe: ${e.toString()}',\r\n-      );\r\n-    }\r\n-  }\r\n-}\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734456706381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,12 +46,16 @@\n       );\r\n     }\r\n   }\r\n \r\n+  // Modified to match base class signature\r\n   @override\r\n-  Future<void> add(String id, Recipe recipe, {required String userId}) async {\r\n+  Future<void> add(String id, Recipe recipe, {String? userId}) async {\r\n     try {\r\n-      final data = recipe.toJson();\r\n+      if (userId == null) {\r\n+        throw BlocException('UserId is required for adding recipes');\r\n+      }\r\n+\r\n       await super.add(id, recipe, userId: userId);\r\n     } catch (e) {\r\n       throw BlocException(\r\n         'Failed to add recipe: ${e.toString()}',\r\n"
                },
                {
                    "date": 1734465938912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,36 @@\n       if (userId == null) {\r\n         throw BlocException('UserId is required for adding recipes');\r\n       }\r\n \r\n-      await super.add(id, recipe, userId: userId);\r\n+      // Debug print before saving\r\n+      print('Saving recipe:\\n${RecipeDebug.prettyPrintRecipe(recipe)}');\r\n+\r\n+      final validation = RecipeDebug.validateRecipeData(recipe);\r\n+      if (validation['critical']!.isNotEmpty) {\r\n+        throw BlocException(\r\n+          'Recipe validation failed:\\n${validation['critical']!.join('\\n')}',\r\n+        );\r\n+      }\r\n+\r\n+      if (validation['warnings']!.isNotEmpty) {\r\n+        print('Recipe warnings:\\n${validation['warnings']!.join('\\n')}');\r\n+      }\r\n+\r\n+      // Convert to JSON and verify data\r\n+      final json = recipe.toJson();\r\n+      print('Recipe JSON:\\n$json');\r\n+\r\n+      await getUserCollection(userId).doc(id).set(json);\r\n+\r\n+      // Verify save\r\n+      final savedDoc = await getUserCollection(userId).doc(id).get();\r\n+      if (!savedDoc.exists) {\r\n+        throw BlocException('Recipe was not saved properly');\r\n+      }\r\n+\r\n+      final savedRecipe = Recipe.fromJson(savedDoc.data() as Map<String, dynamic>);\r\n+      print('Recipe saved and retrieved successfully:\\n${RecipeDebug.prettyPrintRecipe(savedRecipe)}');\r\n     } catch (e) {\r\n       throw BlocException(\r\n         'Failed to add recipe: ${e.toString()}',\r\n       );\r\n"
                }
            ],
            "date": 1734376760281,
            "name": "Commit-0",
            "content": "\r\n\r\nimport 'package:cloud_firestore/cloud_firestore.dart';\r\nimport 'package:experiment_planner/core/exceptions/bloc_exception.dart';\r\nimport 'package:experiment_planner/features/recipes/models/recipe.dart';\r\n\r\nclass RecipeRepository {\r\n  final FirebaseFirestore _firestore;\r\n  static const String _collection = 'recipes';\r\n\r\n  RecipeRepository({FirebaseFirestore? firestore})\r\n      : _firestore = firestore ?? FirebaseFirestore.instance;\r\n\r\n  // Get all recipes for a user\r\n  Future<List<Recipe>> getAll({required String userId}) async {\r\n    try {\r\n      final querySnapshot = await _firestore\r\n          .collection(_collection)\r\n          .where('userId', isEqualTo: userId)\r\n          .orderBy('lastModified', descending: true)\r\n          .get();\r\n\r\n      return querySnapshot.docs\r\n          .map((doc) => Recipe.fromJson(doc.data()))\r\n          .toList();\r\n    } catch (e) {\r\n      throw BlocException(\r\n        'Failed to fetch recipes: ${e.toString()}',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Add a new recipe\r\n  Future<void> add(String id, Recipe recipe, {required String userId}) async {\r\n    try {\r\n      final data = recipe.toJson();\r\n      data['userId'] = userId;\r\n\r\n      await _firestore.collection(_collection).doc(id).set(data);\r\n    } catch (e) {\r\n      throw BlocException(\r\n        'Failed to add recipe: ${e.toString()}',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Update an existing recipe\r\n  Future<void> update(String id, Recipe recipe,\r\n      {required String userId}) async {\r\n    try {\r\n      final docRef = _firestore.collection(_collection).doc(id);\r\n      final doc = await docRef.get();\r\n\r\n      if (!doc.exists) {\r\n        throw BlocException('Recipe not found');\r\n      }\r\n\r\n      final existingData = doc.data();\r\n      if (existingData?['userId'] != userId) {\r\n        throw BlocException('Unauthorized to update this recipe');\r\n      }\r\n\r\n      final data = recipe.toJson();\r\n      data['userId'] = userId;\r\n      data['lastModified'] = Timestamp.now();\r\n\r\n      await docRef.update(data);\r\n    } catch (e) {\r\n      throw BlocException(\r\n        'Failed to update recipe: ${e.toString()}',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Delete a recipe\r\n  Future<void> delete(String id, {required String userId}) async {\r\n    try {\r\n      final docRef = _firestore.collection(_collection).doc(id);\r\n      final doc = await docRef.get();\r\n\r\n      if (!doc.exists) {\r\n        throw BlocException('Recipe not found');\r\n      }\r\n\r\n      final data = doc.data();\r\n      if (data?['userId'] != userId) {\r\n        throw BlocException('Unauthorized to delete this recipe');\r\n      }\r\n\r\n      await docRef.delete();\r\n    } catch (e) {\r\n      throw BlocException(\r\n        'Failed to delete recipe: ${e.toString()}',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Get a specific recipe by ID\r\n  Future<Recipe?> getById(String id, {required String userId}) async {\r\n    try {\r\n      final docSnapshot =\r\n          await _firestore.collection(_collection).doc(id).get();\r\n\r\n      if (!docSnapshot.exists) {\r\n        return null;\r\n      }\r\n\r\n      final data = docSnapshot.data()!;\r\n      if (data['userId'] != userId) {\r\n        throw BlocException('Unauthorized to access this recipe');\r\n      }\r\n\r\n      return Recipe.fromJson(data);\r\n    } catch (e) {\r\n      throw BlocException(\r\n        'Failed to fetch recipe: ${e.toString()}',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Get recipes by substrate type\r\n  Future<List<Recipe>> getBySubstrate(String substrate,\r\n      {required String userId}) async {\r\n    try {\r\n      final querySnapshot = await _firestore\r\n          .collection(_collection)\r\n          .where('userId', isEqualTo: userId)\r\n          .where('substrate', isEqualTo: substrate)\r\n          .orderBy('lastModified', descending: true)\r\n          .get();\r\n\r\n      return querySnapshot.docs\r\n          .map((doc) => Recipe.fromJson(doc.data()))\r\n          .toList();\r\n    } catch (e) {\r\n      throw BlocException(\r\n        'Failed to fetch recipes by substrate: ${e.toString()}',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Stream of recipe updates\r\n  Stream<Recipe> watchRecipe(String id, {required String userId}) {\r\n    return _firestore\r\n        .collection(_collection)\r\n        .doc(id)\r\n        .snapshots()\r\n        .map((snapshot) {\r\n      if (!snapshot.exists) {\r\n        throw BlocException('Recipe not found');\r\n      }\r\n\r\n      final data = snapshot.data()!;\r\n      if (data['userId'] != userId) {\r\n        throw BlocException('Unauthorized to access this recipe');\r\n      }\r\n\r\n      return Recipe.fromJson(data);\r\n    });\r\n  }\r\n\r\n  // Duplicate a recipe\r\n  Future<void> duplicate(String sourceId, String newId, String newName,\r\n      {required String userId}) async {\r\n    try {\r\n      final sourceRecipe = await getById(sourceId, userId: userId);\r\n      if (sourceRecipe == null) {\r\n        throw BlocException('Source recipe not found');\r\n      }\r\n\r\n      final newRecipe = sourceRecipe.copyWith(\r\n        id: newId,\r\n        name: newName,\r\n        version: 1,\r\n        lastModified: DateTime.now(),\r\n      );\r\n\r\n      await add(newId, newRecipe, userId: userId);\r\n    } catch (e) {\r\n      throw BlocException(\r\n        'Failed to duplicate recipe: ${e.toString()}',\r\n      );\r\n    }\r\n  }\r\n}\r\n"
        }
    ]
}