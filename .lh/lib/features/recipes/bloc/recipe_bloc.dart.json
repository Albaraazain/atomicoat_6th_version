{
    "sourceFile": "lib/features/recipes/bloc/recipe_bloc.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1734376760280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1734377251505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-\r\n import 'dart:async';\r\n import 'package:bloc/bloc.dart';\r\n import 'package:experiment_planner/blocs/alarm/bloc/alarm_event.dart';\r\n import 'package:experiment_planner/blocs/recipe/repository/recipe_repository.dart';\r\n@@ -19,8 +18,9 @@\n   final AuthService _authService;\r\n   final SystemStateBloc _systemStateBloc;\r\n   final AlarmBloc _alarmBloc;\r\n   Timer? _executionTimer;\r\n+  StreamSubscription? _userSubscription;\r\n \r\n   RecipeBloc({\r\n     required RecipeRepository repository,\r\n     required AuthService authService,\r\n@@ -41,8 +41,17 @@\n     on<StopRecipeExecution>(_onStopRecipeExecution);\r\n     on<RecipeStepCompleted>(_onRecipeStepCompleted);\r\n     on<LoadRecipeVersions>(_onLoadRecipeVersions);\r\n     on<CompareRecipeVersions>(_onCompareRecipeVersions);\r\n+\r\n+    // Add user subscription\r\n+    _userSubscription = _authService.onUserChanged.listen((userId) {\r\n+      if (userId != null) {\r\n+        add(LoadRecipes());\r\n+      } else {\r\n+        emit(RecipeState.initial());\r\n+      }\r\n+    });\r\n   }\r\n \r\n   RecipeValidationResult _validateRecipe(Recipe recipe) {\r\n     final errors = <String>[];\r\n@@ -522,8 +531,9 @@\n   }\r\n \r\n   @override\r\n   Future<void> close() async {\r\n+    await _userSubscription?.cancel();\r\n     _executionTimer?.cancel();\r\n     return super.close();\r\n   }\r\n   Future<void> _onAddRecipe(\r\n"
                },
                {
                    "date": 1734377300410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,861 @@\n+import 'dart:async';\r\n+import 'package:bloc/bloc.dart';\r\n+import 'package:experiment_planner/core/utils/bloc_utils.dart';\r\n+import 'package:experiment_planner/features/alarms/bloc/alarm_bloc.dart';\r\n+import 'package:experiment_planner/features/alarms/bloc/alarm_event.dart';\r\n+import 'package:experiment_planner/features/alarms/models/alarm.dart';\r\n+import 'package:experiment_planner/features/recipes/models/recipe.dart';\r\n+import 'package:experiment_planner/features/recipes/repository/recipe_repository.dart';\r\n+import 'package:experiment_planner/features/system/bloc/system_state_event.dart';\r\n+import '../../auth/services/auth_service.dart';\r\n+import '../../system/bloc/system_state_bloc.dart';\r\n+import 'recipe_event.dart';\r\n+import 'recipe_state.dart';\r\n+import '../models/recipe_validation_result.dart';\r\n+\r\n+class RecipeBloc extends Bloc<RecipeEvent, RecipeState> {\r\n+  final RecipeRepository _repository;\r\n+  final AuthService _authService;\r\n+  final SystemStateBloc _systemStateBloc;\r\n+  final AlarmBloc _alarmBloc;\r\n+  Timer? _executionTimer;\r\n+  StreamSubscription? _userSubscription;\r\n+\r\n+  RecipeBloc({\r\n+    required RecipeRepository repository,\r\n+    required AuthService authService,\r\n+    required SystemStateBloc systemStateBloc,\r\n+    required AlarmBloc alarmBloc,\r\n+  })  : _repository = repository,\r\n+        _authService = authService,\r\n+        _systemStateBloc = systemStateBloc,\r\n+        _alarmBloc = alarmBloc,\r\n+        super(RecipeState.initial()) {\r\n+    on<LoadRecipes>(_onLoadRecipes);\r\n+    on<AddRecipe>(_onAddRecipe);\r\n+    on<UpdateRecipe>(_onUpdateRecipe);\r\n+    on<DeleteRecipe>(_onDeleteRecipe);\r\n+    on<StartRecipeExecution>(_onStartRecipeExecution);\r\n+    on<PauseRecipeExecution>(_onPauseRecipeExecution);\r\n+    on<ResumeRecipeExecution>(_onResumeRecipeExecution);\r\n+    on<StopRecipeExecution>(_onStopRecipeExecution);\r\n+    on<RecipeStepCompleted>(_onRecipeStepCompleted);\r\n+    on<LoadRecipeVersions>(_onLoadRecipeVersions);\r\n+    on<CompareRecipeVersions>(_onCompareRecipeVersions);\r\n+\r\n+    // Add user subscription\r\n+    _userSubscription = _authService.onUserChanged.listen((userId) {\r\n+      if (userId != null) {\r\n+        add(LoadRecipes());\r\n+      } else {\r\n+        emit(RecipeState.initial());\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  RecipeValidationResult _validateRecipe(Recipe recipe) {\r\n+    final errors = <String>[];\r\n+\r\n+    // Validate basic recipe properties\r\n+    if (recipe.name.isEmpty) {\r\n+      errors.add('Recipe name is required');\r\n+    }\r\n+    if (recipe.substrate.isEmpty) {\r\n+      errors.add('Substrate is required');\r\n+    }\r\n+    if (recipe.steps.isEmpty) {\r\n+      errors.add('Recipe must have at least one step');\r\n+    }\r\n+\r\n+    // Validate each step\r\n+    for (int i = 0; i < recipe.steps.length; i++) {\r\n+      final stepErrors = _validateStep(recipe.steps[i], i);\r\n+      errors.addAll(stepErrors);\r\n+    }\r\n+\r\n+    return RecipeValidationResult(\r\n+      isValid: errors.isEmpty,\r\n+      errors: errors,\r\n+    );\r\n+  }\r\n+\r\n+  List<String> _validateStep(RecipeStep step, int index) {\r\n+    final errors = <String>[];\r\n+    final prefix = 'Step ${index + 1}';\r\n+\r\n+    switch (step.type) {\r\n+      case StepType.valve:\r\n+        if (!step.parameters.containsKey('duration')) {\r\n+          errors.add('$prefix: Valve duration is required');\r\n+        } else if (step.parameters['duration'] <= 0) {\r\n+          errors.add('$prefix: Valve duration must be positive');\r\n+        }\r\n+        if (!step.parameters.containsKey('valveType')) {\r\n+          errors.add('$prefix: Valve type is required');\r\n+        }\r\n+        break;\r\n+\r\n+      case StepType.purge:\r\n+        if (!step.parameters.containsKey('duration')) {\r\n+          errors.add('$prefix: Purge duration is required');\r\n+        } else if (step.parameters['duration'] <= 0) {\r\n+          errors.add('$prefix: Purge duration must be positive');\r\n+        }\r\n+        break;\r\n+\r\n+      case StepType.loop:\r\n+        if (!step.parameters.containsKey('iterations')) {\r\n+          errors.add('$prefix: Loop iterations is required');\r\n+        } else if (step.parameters['iterations'] <= 0) {\r\n+          errors.add('$prefix: Loop iterations must be positive');\r\n+        }\r\n+        if (step.subSteps == null || step.subSteps!.isEmpty) {\r\n+          errors.add('$prefix: Loop must contain substeps');\r\n+        } else {\r\n+          for (int i = 0; i < step.subSteps!.length; i++) {\r\n+            final substepErrors = _validateStep(step.subSteps![i], i);\r\n+            errors.addAll(substepErrors.map((e) => '$prefix (Substep ${i + 1}): $e'));\r\n+          }\r\n+        }\r\n+        break;\r\n+\r\n+      case StepType.setParameter:\r\n+        if (!step.parameters.containsKey('component')) {\r\n+          errors.add('$prefix: Component name is required');\r\n+        }\r\n+        if (!step.parameters.containsKey('parameter')) {\r\n+          errors.add('$prefix: Parameter name is required');\r\n+        }\r\n+        if (!step.parameters.containsKey('value')) {\r\n+          errors.add('$prefix: Parameter value is required');\r\n+        }\r\n+        break;\r\n+    }\r\n+\r\n+    return errors;\r\n+  }\r\n+\r\n+  Future<bool> _handleStepError(\r\n+    RecipeStep step,\r\n+    dynamic error,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    final errorMessage = error.toString();\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Error executing step: $errorMessage',\r\n+      severity: AlarmSeverity.critical,\r\n+    ));\r\n+\r\n+    switch (step.type) {\r\n+      case StepType.valve:\r\n+        return await _recoverValveError(step);\r\n+      case StepType.purge:\r\n+        return await _recoverPurgeError(step);\r\n+      case StepType.setParameter:\r\n+        return await _recoverParameterError(step);\r\n+      case StepType.loop:\r\n+        return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<bool> _recoverValveError(RecipeStep step) async {\r\n+    try {\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'Valve 1': {'status': 0.0},\r\n+        'Valve 2': {'status': 0.0},\r\n+      }));\r\n+      return true;\r\n+    } catch (e) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<bool> _recoverPurgeError(RecipeStep step) async {\r\n+    try {\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'MFC': {'flow_rate': 0.0},\r\n+        'Valve 1': {'status': 0.0},\r\n+        'Valve 2': {'status': 0.0},\r\n+      }));\r\n+      return true;\r\n+    } catch (e) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<bool> _recoverParameterError(RecipeStep step) async {\r\n+    try {\r\n+      final componentName = step.parameters['component'] as String;\r\n+      final parameter = step.parameters['parameter'] as String;\r\n+\r\n+      switch (parameter) {\r\n+        case 'temperature':\r\n+          _systemStateBloc.add(UpdateSystemParameters({\r\n+            componentName: {'temperature': 25.0},\r\n+          }));\r\n+          break;\r\n+        case 'pressure':\r\n+          _systemStateBloc.add(UpdateSystemParameters({\r\n+            componentName: {'pressure': 1.0},\r\n+          }));\r\n+          break;\r\n+        default:\r\n+          return false;\r\n+      }\r\n+      return true;\r\n+    } catch (e) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onLoadRecipes(\r\n+    LoadRecipes event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      final recipes = await _repository.getAll(userId: userId);\r\n+      emit(state.copyWith(\r\n+        recipes: recipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onStartRecipeExecution(\r\n+    StartRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      final recipe = state.recipes.firstWhere(\r\n+        (r) => r.id == event.recipeId,\r\n+        orElse: () => throw Exception('Recipe not found'),\r\n+      );\r\n+\r\n+      // Add validation\r\n+      final validation = _validateRecipe(recipe);\r\n+      if (!validation.isValid) {\r\n+        throw Exception('Invalid recipe: ${validation.errors.join(', ')}');\r\n+      }\r\n+\r\n+      // Check system readiness\r\n+      _systemStateBloc.add(CheckSystemReadiness());\r\n+      if (!_systemStateBloc.state.isReadinessCheckPassed) {\r\n+        throw Exception('System not ready for recipe execution');\r\n+      }\r\n+\r\n+      // Start system if not running\r\n+      if (!_systemStateBloc.state.isSystemRunning) {\r\n+        _systemStateBloc.add(StartSystem());\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        activeRecipe: recipe,\r\n+        currentStepIndex: 0,\r\n+        executionStatus: RecipeExecutionStatus.running,\r\n+      ));\r\n+\r\n+      // Execute first step\r\n+      await _executeStep(recipe.steps[0], emit);\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        executionStatus: RecipeExecutionStatus.error,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeStep(RecipeStep step, Emitter<RecipeState> emit) async {\r\n+    try {\r\n+      switch (step.type) {\r\n+        case StepType.valve:\r\n+          await _executeValveStep(step);\r\n+          break;\r\n+        case StepType.purge:\r\n+          await _executePurgeStep(step);\r\n+          break;\r\n+        case StepType.loop:\r\n+          await _executeLoopStep(step, emit);\r\n+          break;\r\n+        case StepType.setParameter:\r\n+          await _executeSetParameterStep(step);\r\n+          break;\r\n+      }\r\n+    } catch (error) {\r\n+      // Add error recovery\r\n+      final recovered = await _handleStepError(step, error, emit);\r\n+      if (!recovered) {\r\n+        _alarmBloc.add(AddAlarm(\r\n+          message: 'Unrecoverable error in recipe execution: ${error.toString()}',\r\n+          severity: AlarmSeverity.critical,\r\n+        ));\r\n+        emit(state.copyWith(\r\n+          executionStatus: RecipeExecutionStatus.error,\r\n+          error: error.toString(),\r\n+        ));\r\n+        throw error;\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeValveStep(RecipeStep step) async {\r\n+    final componentName = step.parameters['valveType'] == ValveType.valveA\r\n+        ? 'Valve 1'\r\n+        : 'Valve 2';\r\n+    final duration = step.parameters['duration'] as int;\r\n+\r\n+    _systemStateBloc.add(UpdateSystemParameters({\r\n+      componentName: {'status': 1.0},\r\n+    }));\r\n+\r\n+    await Future.delayed(Duration(seconds: duration));\r\n+\r\n+    _systemStateBloc.add(UpdateSystemParameters({\r\n+      componentName: {'status': 0.0},\r\n+    }));\r\n+  }\r\n+\r\n+    Future<void> _executePurgeStep(RecipeStep step) async {\r\n+    final duration = step.parameters['duration'] as int;\r\n+    final gasFlow = step.parameters['gasFlow'] as double? ?? 100.0;\r\n+\r\n+    try {\r\n+      // Close valves\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'Valve 1': {'status': 0.0},\r\n+        'Valve 2': {'status': 0.0},\r\n+      }));\r\n+\r\n+      // Set MFC to purge flow rate\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'MFC': {'flow_rate': gasFlow},\r\n+      }));\r\n+\r\n+      await Future.delayed(Duration(seconds: duration));\r\n+\r\n+      // Reset MFC flow rate\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'MFC': {'flow_rate': 0.0},\r\n+      }));\r\n+    } catch (error) {\r\n+      _alarmBloc.add(AddAlarm(\r\n+        message: 'Error during purge step: ${error.toString()}',\r\n+        severity: AlarmSeverity.critical,\r\n+      ));\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeLoopStep(RecipeStep step, Emitter<RecipeState> emit) async {\r\n+    final iterations = step.parameters['iterations'] as int;\r\n+    final temperature = step.parameters['temperature'] as double?;\r\n+    final pressure = step.parameters['pressure'] as double?;\r\n+    final subSteps = step.subSteps;\r\n+\r\n+    if (subSteps == null || subSteps.isEmpty) {\r\n+      throw Exception('Loop step has no substeps');\r\n+    }\r\n+\r\n+    try {\r\n+      // Set chamber parameters if specified\r\n+      if (temperature != null || pressure != null) {\r\n+        final updates = <String, Map<String, double>>{};\r\n+\r\n+        if (temperature != null) {\r\n+          updates['Reaction Chamber'] = {'temperature': temperature};\r\n+          await _waitForTemperatureStabilization('Reaction Chamber', temperature);\r\n+        }\r\n+\r\n+        if (pressure != null) {\r\n+          updates['Pressure Control System'] = {'pressure': pressure};\r\n+          await _waitForPressureStabilization(pressure);\r\n+        }\r\n+\r\n+        if (updates.isNotEmpty) {\r\n+          _systemStateBloc.add(UpdateSystemParameters(updates));\r\n+        }\r\n+      }\r\n+\r\n+      // Execute loop iterations\r\n+      for (int i = 0; i < iterations; i++) {\r\n+        if (state.executionStatus != RecipeExecutionStatus.running) {\r\n+          break;\r\n+        }\r\n+\r\n+        emit(state.copyWith(\r\n+          currentStepIndex: state.currentStepIndex,\r\n+          executionStatus: RecipeExecutionStatus.running,\r\n+        ));\r\n+\r\n+        for (final subStep in subSteps) {\r\n+          await _executeStep(subStep, emit);\r\n+        }\r\n+      }\r\n+    } catch (error) {\r\n+      _alarmBloc.add(AddAlarm(\r\n+        message: 'Error in loop execution: ${error.toString()}',\r\n+        severity: AlarmSeverity.critical,\r\n+      ));\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeSetParameterStep(RecipeStep step) async {\r\n+    final componentName = step.parameters['component'] as String;\r\n+    final parameter = step.parameters['parameter'] as String;\r\n+    final value = step.parameters['value'] as double;\r\n+\r\n+    try {\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        componentName: {parameter: value},\r\n+      }));\r\n+\r\n+      // Wait for parameter to stabilize\r\n+      await _waitForParameterStabilization(\r\n+        componentName,\r\n+        parameter,\r\n+        value,\r\n+      );\r\n+    } catch (error) {\r\n+      _alarmBloc.add(AddAlarm(\r\n+        message: 'Error setting parameter $parameter for $componentName: ${error.toString()}',\r\n+        severity: AlarmSeverity.critical,\r\n+      ));\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  // Helper methods for parameter stabilization\r\n+  Future<void> _waitForTemperatureStabilization(\r\n+    String componentName,\r\n+    double targetTemperature,\r\n+  ) async {\r\n+    const tolerance = 2.0; // °C\r\n+    const timeout = Duration(minutes: 5);\r\n+    final stopwatch = Stopwatch()..start();\r\n+\r\n+    while (stopwatch.elapsed < timeout) {\r\n+      final currentTemp = _getCurrentValue(componentName, 'temperature');\r\n+      if ((currentTemp - targetTemperature).abs() <= tolerance) {\r\n+        return;\r\n+      }\r\n+      await Future.delayed(const Duration(seconds: 1));\r\n+    }\r\n+    throw Exception('Temperature stabilization timeout');\r\n+  }\r\n+\r\n+  Future<void> _waitForPressureStabilization(double targetPressure) async {\r\n+    const tolerance = 0.05; // atm\r\n+    const timeout = Duration(minutes: 2);\r\n+    final stopwatch = Stopwatch()..start();\r\n+\r\n+    while (stopwatch.elapsed < timeout) {\r\n+      final currentPressure = _getCurrentValue('Pressure Control System', 'pressure');\r\n+      if ((currentPressure - targetPressure).abs() <= tolerance) {\r\n+        return;\r\n+      }\r\n+      await Future.delayed(const Duration(seconds: 1));\r\n+    }\r\n+    throw Exception('Pressure stabilization timeout');\r\n+  }\r\n+\r\n+  Future<void> _waitForParameterStabilization(\r\n+    String componentName,\r\n+    String parameter,\r\n+    double targetValue,\r\n+  ) async {\r\n+    final tolerance = _getToleranceForParameter(parameter);\r\n+    const timeout = Duration(minutes: 2);\r\n+    final stopwatch = Stopwatch()..start();\r\n+\r\n+    while (stopwatch.elapsed < timeout) {\r\n+      final currentValue = _getCurrentValue(componentName, parameter);\r\n+      if ((currentValue - targetValue).abs() <= tolerance) {\r\n+        return;\r\n+      }\r\n+      await Future.delayed(const Duration(seconds: 1));\r\n+    }\r\n+    throw Exception('Parameter stabilization timeout: $parameter');\r\n+  }\r\n+\r\n+  double _getToleranceForParameter(String parameter) {\r\n+    switch (parameter) {\r\n+      case 'temperature': return 2.0;\r\n+      case 'pressure': return 0.05;\r\n+      case 'flow_rate': return 1.0;\r\n+      default: return 0.1;\r\n+    }\r\n+  }\r\n+\r\n+  double _getCurrentValue(String componentName, String parameter) {\r\n+    // Get current value from system state\r\n+    final components = _systemStateBloc.state.currentSystemState['components']\r\n+        as Map<String, dynamic>?;\r\n+\r\n+    if (components == null) {\r\n+      throw Exception('No components found in system state');\r\n+    }\r\n+\r\n+    final component = components[componentName] as Map<String, dynamic>?;\r\n+    if (component == null) {\r\n+      throw Exception('Component not found: $componentName');\r\n+    }\r\n+\r\n+    final currentValues = component['currentValues'] as Map<String, dynamic>?;\r\n+    if (currentValues == null) {\r\n+      throw Exception('No current values for component: $componentName');\r\n+    }\r\n+\r\n+    final value = currentValues[parameter] as double?;\r\n+    if (value == null) {\r\n+      throw Exception('Parameter not found: $parameter');\r\n+    }\r\n+\r\n+    return value;\r\n+  }\r\n+\r\n+  @override\r\n+  Future<void> close() async {\r\n+    await _userSubscription?.cancel();\r\n+    _executionTimer?.cancel();\r\n+    return super.close();\r\n+  }\r\n+  Future<void> _onAddRecipe(\r\n+    AddRecipe event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      await _repository.add(event.recipe.id, event.recipe, userId: userId);\r\n+\r\n+      final updatedRecipes = [...state.recipes, event.recipe];\r\n+      emit(state.copyWith(\r\n+        recipes: updatedRecipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onUpdateRecipe(\r\n+    UpdateRecipe event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      await _repository.update(event.recipe.id, event.recipe, userId: userId);\r\n+\r\n+      final updatedRecipes = state.recipes.map((recipe) =>\r\n+        recipe.id == event.recipe.id ? event.recipe : recipe\r\n+      ).toList();\r\n+\r\n+      emit(state.copyWith(\r\n+        recipes: updatedRecipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onDeleteRecipe(\r\n+    DeleteRecipe event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      await _repository.delete(event.recipeId, userId: userId);\r\n+\r\n+      final updatedRecipes = state.recipes\r\n+          .where((recipe) => recipe.id != event.recipeId)\r\n+          .toList();\r\n+\r\n+      emit(state.copyWith(\r\n+        recipes: updatedRecipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onPauseRecipeExecution(\r\n+    PauseRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    if (state.executionStatus != RecipeExecutionStatus.running) {\r\n+      return;\r\n+    }\r\n+\r\n+    _executionTimer?.cancel();\r\n+    emit(state.copyWith(\r\n+      executionStatus: RecipeExecutionStatus.paused,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onResumeRecipeExecution(\r\n+    ResumeRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    if (state.executionStatus != RecipeExecutionStatus.paused) {\r\n+      return;\r\n+    }\r\n+\r\n+    emit(state.copyWith(\r\n+      executionStatus: RecipeExecutionStatus.running,\r\n+    ));\r\n+\r\n+    if (state.activeRecipe != null) {\r\n+      await _executeStep(\r\n+        state.activeRecipe!.steps[state.currentStepIndex],\r\n+        emit,\r\n+      );\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onStopRecipeExecution(\r\n+    StopRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      _executionTimer?.cancel();\r\n+      _executionTimer = null;\r\n+\r\n+      _systemStateBloc.add(StopSystem());\r\n+\r\n+      emit(RecipeState.initial()); // Reset to initial state instead of using copyWith\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onRecipeStepCompleted(\r\n+    RecipeStepCompleted event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    if (state.activeRecipe == null ||\r\n+        state.executionStatus != RecipeExecutionStatus.running) {\r\n+      return;\r\n+    }\r\n+\r\n+    final nextStepIndex = event.stepIndex + 1;\r\n+    if (nextStepIndex >= state.activeRecipe!.steps.length) {\r\n+      // Recipe completed\r\n+      emit(state.copyWith(\r\n+        executionStatus: RecipeExecutionStatus.completed,\r\n+        currentStepIndex: 0,\r\n+      ));\r\n+      _systemStateBloc.add(StopSystem());\r\n+      return;\r\n+    }\r\n+\r\n+    emit(state.copyWith(currentStepIndex: nextStepIndex));\r\n+    await _executeStep(\r\n+      state.activeRecipe!.steps[nextStepIndex],\r\n+      emit,\r\n+    );\r\n+  }\r\n+\r\n+  Future<void> _onLoadRecipeVersions(\r\n+    LoadRecipeVersions event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      final versions = await _repository.getAll(userId: userId);\r\n+      final recipeVersions = versions\r\n+          .where((recipe) => recipe.id == event.recipeId)\r\n+          .toList()\r\n+        ..sort((a, b) => b.version.compareTo(a.version));\r\n+\r\n+      emit(state.copyWith(\r\n+        recipeVersions: {\r\n+          ...state.recipeVersions,\r\n+          event.recipeId: recipeVersions,\r\n+        },\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onCompareRecipeVersions(\r\n+    CompareRecipeVersions event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      final versions = state.recipeVersions[event.recipeId] ?? [];\r\n+      final versionA = versions.firstWhere((r) => r.version == event.versionA);\r\n+      final versionB = versions.firstWhere((r) => r.version == event.versionB);\r\n+\r\n+      final comparison = _compareRecipes(versionA, versionB);\r\n+\r\n+      emit(state.copyWith(\r\n+        versionComparison: comparison,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Map<String, dynamic> _compareRecipes(Recipe oldVersion, Recipe newVersion) {\r\n+    final differences = <String, dynamic>{};\r\n+\r\n+    if (oldVersion.name != newVersion.name) {\r\n+      differences['name'] = {\r\n+        'old': oldVersion.name,\r\n+        'new': newVersion.name,\r\n+      };\r\n+    }\r\n+\r\n+    if (oldVersion.substrate != newVersion.substrate) {\r\n+      differences['substrate'] = {\r\n+        'old': oldVersion.substrate,\r\n+        'new': newVersion.substrate,\r\n+      };\r\n+    }\r\n+\r\n+    differences['steps'] = _compareSteps(oldVersion.steps, newVersion.steps);\r\n+    return differences;\r\n+  }\r\n+\r\n+  List<Map<String, dynamic>> _compareSteps(\r\n+    List<RecipeStep> oldSteps,\r\n+    List<RecipeStep> newSteps,\r\n+  ) {\r\n+    final differences = <Map<String, dynamic>>[];\r\n+    final maxLength = oldSteps.length > newSteps.length\r\n+        ? oldSteps.length\r\n+        : newSteps.length;\r\n+\r\n+    for (var i = 0; i < maxLength; i++) {\r\n+      if (i < oldSteps.length && i < newSteps.length) {\r\n+        if (!_areStepsEqual(oldSteps[i], newSteps[i])) {\r\n+          differences.add({\r\n+            'index': i,\r\n+            'old': _stepToString(oldSteps[i]),\r\n+            'new': _stepToString(newSteps[i]),\r\n+          });\r\n+        }\r\n+      } else if (i < oldSteps.length) {\r\n+        differences.add({\r\n+          'index': i,\r\n+          'old': _stepToString(oldSteps[i]),\r\n+          'new': null,\r\n+        });\r\n+      } else {\r\n+        differences.add({\r\n+          'index': i,\r\n+          'old': null,\r\n+          'new': _stepToString(newSteps[i]),\r\n+        });\r\n+      }\r\n+    }\r\n+\r\n+    return differences;\r\n+  }\r\n+\r\n+  bool _areStepsEqual(RecipeStep step1, RecipeStep step2) {\r\n+    return step1.type == step2.type &&\r\n+           _areParametersEqual(step1.parameters, step2.parameters);\r\n+  }\r\n+\r\n+  bool _areParametersEqual(\r\n+    Map<String, dynamic> params1,\r\n+    Map<String, dynamic> params2,\r\n+  ) {\r\n+    return params1.length == params2.length &&\r\n+           params1.entries.every((entry) =>\r\n+             params2.containsKey(entry.key) &&\r\n+             params2[entry.key] == entry.value);\r\n+  }\r\n+\r\n+  String _stepToString(RecipeStep step) {\r\n+    switch (step.type) {\r\n+      case StepType.loop:\r\n+        return 'Loop ${step.parameters['iterations']} times';\r\n+      case StepType.valve:\r\n+        return '${step.parameters['valveType'] == ValveType.valveA ? 'Valve A' : 'Valve B'} '\r\n+               'for ${step.parameters['duration']}s';\r\n+      case StepType.purge:\r\n+        return 'Purge for ${step.parameters['duration']}s';\r\n+      case StepType.setParameter:\r\n+        return 'Set ${step.parameters['component']} ${step.parameters['parameter']} '\r\n+               'to ${step.parameters['value']}';\r\n+    }\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734377675811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,861 @@\n+import 'dart:async';\r\n+import 'package:bloc/bloc.dart';\r\n+import 'package:experiment_planner/core/utils/bloc_utils.dart';\r\n+import 'package:experiment_planner/features/alarms/bloc/alarm_bloc.dart';\r\n+import 'package:experiment_planner/features/alarms/bloc/alarm_event.dart';\r\n+import 'package:experiment_planner/features/alarms/models/alarm.dart';\r\n+import 'package:experiment_planner/features/recipes/models/recipe.dart';\r\n+import 'package:experiment_planner/features/recipes/repository/recipe_repository.dart';\r\n+import 'package:experiment_planner/features/system/bloc/system_state_event.dart';\r\n+import '../../auth/services/auth_service.dart';\r\n+import '../../system/bloc/system_state_bloc.dart';\r\n+import 'recipe_event.dart';\r\n+import 'recipe_state.dart';\r\n+import '../models/recipe_validation_result.dart';\r\n+\r\n+class RecipeBloc extends Bloc<RecipeEvent, RecipeState> {\r\n+  final RecipeRepository _repository;\r\n+  final AuthService _authService;\r\n+  final SystemStateBloc _systemStateBloc;\r\n+  final AlarmBloc _alarmBloc;\r\n+  Timer? _executionTimer;\r\n+  StreamSubscription? _userSubscription;\r\n+\r\n+  RecipeBloc({\r\n+    required RecipeRepository repository,\r\n+    required AuthService authService,\r\n+    required SystemStateBloc systemStateBloc,\r\n+    required AlarmBloc alarmBloc,\r\n+  })  : _repository = repository,\r\n+        _authService = authService,\r\n+        _systemStateBloc = systemStateBloc,\r\n+        _alarmBloc = alarmBloc,\r\n+        super(RecipeState.initial()) {\r\n+    on<LoadRecipes>(_onLoadRecipes);\r\n+    on<AddRecipe>(_onAddRecipe);\r\n+    on<UpdateRecipe>(_onUpdateRecipe);\r\n+    on<DeleteRecipe>(_onDeleteRecipe);\r\n+    on<StartRecipeExecution>(_onStartRecipeExecution);\r\n+    on<PauseRecipeExecution>(_onPauseRecipeExecution);\r\n+    on<ResumeRecipeExecution>(_onResumeRecipeExecution);\r\n+    on<StopRecipeExecution>(_onStopRecipeExecution);\r\n+    on<RecipeStepCompleted>(_onRecipeStepCompleted);\r\n+    on<LoadRecipeVersions>(_onLoadRecipeVersions);\r\n+    on<CompareRecipeVersions>(_onCompareRecipeVersions);\r\n+\r\n+    // Add user subscription\r\n+    _userSubscription = _authService.onUserChanged.listen((userId) {\r\n+      if (userId != null) {\r\n+        add(LoadRecipes());\r\n+      } else {\r\n+        emit(RecipeState.initial());\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  RecipeValidationResult _validateRecipe(Recipe recipe) {\r\n+    final errors = <String>[];\r\n+\r\n+    // Validate basic recipe properties\r\n+    if (recipe.name.isEmpty) {\r\n+      errors.add('Recipe name is required');\r\n+    }\r\n+    if (recipe.substrate.isEmpty) {\r\n+      errors.add('Substrate is required');\r\n+    }\r\n+    if (recipe.steps.isEmpty) {\r\n+      errors.add('Recipe must have at least one step');\r\n+    }\r\n+\r\n+    // Validate each step\r\n+    for (int i = 0; i < recipe.steps.length; i++) {\r\n+      final stepErrors = _validateStep(recipe.steps[i], i);\r\n+      errors.addAll(stepErrors);\r\n+    }\r\n+\r\n+    return RecipeValidationResult(\r\n+      isValid: errors.isEmpty,\r\n+      errors: errors,\r\n+    );\r\n+  }\r\n+\r\n+  List<String> _validateStep(RecipeStep step, int index) {\r\n+    final errors = <String>[];\r\n+    final prefix = 'Step ${index + 1}';\r\n+\r\n+    switch (step.type) {\r\n+      case StepType.valve:\r\n+        if (!step.parameters.containsKey('duration')) {\r\n+          errors.add('$prefix: Valve duration is required');\r\n+        } else if (step.parameters['duration'] <= 0) {\r\n+          errors.add('$prefix: Valve duration must be positive');\r\n+        }\r\n+        if (!step.parameters.containsKey('valveType')) {\r\n+          errors.add('$prefix: Valve type is required');\r\n+        }\r\n+        break;\r\n+\r\n+      case StepType.purge:\r\n+        if (!step.parameters.containsKey('duration')) {\r\n+          errors.add('$prefix: Purge duration is required');\r\n+        } else if (step.parameters['duration'] <= 0) {\r\n+          errors.add('$prefix: Purge duration must be positive');\r\n+        }\r\n+        break;\r\n+\r\n+      case StepType.loop:\r\n+        if (!step.parameters.containsKey('iterations')) {\r\n+          errors.add('$prefix: Loop iterations is required');\r\n+        } else if (step.parameters['iterations'] <= 0) {\r\n+          errors.add('$prefix: Loop iterations must be positive');\r\n+        }\r\n+        if (step.subSteps == null || step.subSteps!.isEmpty) {\r\n+          errors.add('$prefix: Loop must contain substeps');\r\n+        } else {\r\n+          for (int i = 0; i < step.subSteps!.length; i++) {\r\n+            final substepErrors = _validateStep(step.subSteps![i], i);\r\n+            errors.addAll(substepErrors.map((e) => '$prefix (Substep ${i + 1}): $e'));\r\n+          }\r\n+        }\r\n+        break;\r\n+\r\n+      case StepType.setParameter:\r\n+        if (!step.parameters.containsKey('component')) {\r\n+          errors.add('$prefix: Component name is required');\r\n+        }\r\n+        if (!step.parameters.containsKey('parameter')) {\r\n+          errors.add('$prefix: Parameter name is required');\r\n+        }\r\n+        if (!step.parameters.containsKey('value')) {\r\n+          errors.add('$prefix: Parameter value is required');\r\n+        }\r\n+        break;\r\n+    }\r\n+\r\n+    return errors;\r\n+  }\r\n+\r\n+  Future<bool> _handleStepError(\r\n+    RecipeStep step,\r\n+    dynamic error,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    final errorMessage = error.toString();\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Error executing step: $errorMessage',\r\n+      severity: AlarmSeverity.critical,\r\n+    ));\r\n+\r\n+    switch (step.type) {\r\n+      case StepType.valve:\r\n+        return await _recoverValveError(step);\r\n+      case StepType.purge:\r\n+        return await _recoverPurgeError(step);\r\n+      case StepType.setParameter:\r\n+        return await _recoverParameterError(step);\r\n+      case StepType.loop:\r\n+        return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<bool> _recoverValveError(RecipeStep step) async {\r\n+    try {\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'Valve 1': {'status': 0.0},\r\n+        'Valve 2': {'status': 0.0},\r\n+      }));\r\n+      return true;\r\n+    } catch (e) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<bool> _recoverPurgeError(RecipeStep step) async {\r\n+    try {\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'MFC': {'flow_rate': 0.0},\r\n+        'Valve 1': {'status': 0.0},\r\n+        'Valve 2': {'status': 0.0},\r\n+      }));\r\n+      return true;\r\n+    } catch (e) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<bool> _recoverParameterError(RecipeStep step) async {\r\n+    try {\r\n+      final componentName = step.parameters['component'] as String;\r\n+      final parameter = step.parameters['parameter'] as String;\r\n+\r\n+      switch (parameter) {\r\n+        case 'temperature':\r\n+          _systemStateBloc.add(UpdateSystemParameters({\r\n+            componentName: {'temperature': 25.0},\r\n+          }));\r\n+          break;\r\n+        case 'pressure':\r\n+          _systemStateBloc.add(UpdateSystemParameters({\r\n+            componentName: {'pressure': 1.0},\r\n+          }));\r\n+          break;\r\n+        default:\r\n+          return false;\r\n+      }\r\n+      return true;\r\n+    } catch (e) {\r\n+      return false;\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onLoadRecipes(\r\n+    LoadRecipes event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      final recipes = await _repository.getAll(userId: userId);\r\n+      emit(state.copyWith(\r\n+        recipes: recipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onStartRecipeExecution(\r\n+    StartRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      final recipe = state.recipes.firstWhere(\r\n+        (r) => r.id == event.recipeId,\r\n+        orElse: () => throw Exception('Recipe not found'),\r\n+      );\r\n+\r\n+      // Add validation\r\n+      final validation = _validateRecipe(recipe);\r\n+      if (!validation.isValid) {\r\n+        throw Exception('Invalid recipe: ${validation.errors.join(', ')}');\r\n+      }\r\n+\r\n+      // Check system readiness\r\n+      _systemStateBloc.add(CheckSystemReadiness());\r\n+      if (!_systemStateBloc.state.isReadinessCheckPassed) {\r\n+        throw Exception('System not ready for recipe execution');\r\n+      }\r\n+\r\n+      // Start system if not running\r\n+      if (!_systemStateBloc.state.isSystemRunning) {\r\n+        _systemStateBloc.add(StartSystem());\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        activeRecipe: recipe,\r\n+        currentStepIndex: 0,\r\n+        executionStatus: RecipeExecutionStatus.running,\r\n+      ));\r\n+\r\n+      // Execute first step\r\n+      await _executeStep(recipe.steps[0], emit);\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        executionStatus: RecipeExecutionStatus.error,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeStep(RecipeStep step, Emitter<RecipeState> emit) async {\r\n+    try {\r\n+      switch (step.type) {\r\n+        case StepType.valve:\r\n+          await _executeValveStep(step);\r\n+          break;\r\n+        case StepType.purge:\r\n+          await _executePurgeStep(step);\r\n+          break;\r\n+        case StepType.loop:\r\n+          await _executeLoopStep(step, emit);\r\n+          break;\r\n+        case StepType.setParameter:\r\n+          await _executeSetParameterStep(step);\r\n+          break;\r\n+      }\r\n+    } catch (error) {\r\n+      // Add error recovery\r\n+      final recovered = await _handleStepError(step, error, emit);\r\n+      if (!recovered) {\r\n+        _alarmBloc.add(AddAlarm(\r\n+          message: 'Unrecoverable error in recipe execution: ${error.toString()}',\r\n+          severity: AlarmSeverity.critical,\r\n+        ));\r\n+        emit(state.copyWith(\r\n+          executionStatus: RecipeExecutionStatus.error,\r\n+          error: error.toString(),\r\n+        ));\r\n+        throw error;\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeValveStep(RecipeStep step) async {\r\n+    final componentName = step.parameters['valveType'] == ValveType.valveA\r\n+        ? 'Valve 1'\r\n+        : 'Valve 2';\r\n+    final duration = step.parameters['duration'] as int;\r\n+\r\n+    _systemStateBloc.add(UpdateSystemParameters({\r\n+      componentName: {'status': 1.0},\r\n+    }));\r\n+\r\n+    await Future.delayed(Duration(seconds: duration));\r\n+\r\n+    _systemStateBloc.add(UpdateSystemParameters({\r\n+      componentName: {'status': 0.0},\r\n+    }));\r\n+  }\r\n+\r\n+    Future<void> _executePurgeStep(RecipeStep step) async {\r\n+    final duration = step.parameters['duration'] as int;\r\n+    final gasFlow = step.parameters['gasFlow'] as double? ?? 100.0;\r\n+\r\n+    try {\r\n+      // Close valves\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'Valve 1': {'status': 0.0},\r\n+        'Valve 2': {'status': 0.0},\r\n+      }));\r\n+\r\n+      // Set MFC to purge flow rate\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'MFC': {'flow_rate': gasFlow},\r\n+      }));\r\n+\r\n+      await Future.delayed(Duration(seconds: duration));\r\n+\r\n+      // Reset MFC flow rate\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        'MFC': {'flow_rate': 0.0},\r\n+      }));\r\n+    } catch (error) {\r\n+      _alarmBloc.add(AddAlarm(\r\n+        message: 'Error during purge step: ${error.toString()}',\r\n+        severity: AlarmSeverity.critical,\r\n+      ));\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeLoopStep(RecipeStep step, Emitter<RecipeState> emit) async {\r\n+    final iterations = step.parameters['iterations'] as int;\r\n+    final temperature = step.parameters['temperature'] as double?;\r\n+    final pressure = step.parameters['pressure'] as double?;\r\n+    final subSteps = step.subSteps;\r\n+\r\n+    if (subSteps == null || subSteps.isEmpty) {\r\n+      throw Exception('Loop step has no substeps');\r\n+    }\r\n+\r\n+    try {\r\n+      // Set chamber parameters if specified\r\n+      if (temperature != null || pressure != null) {\r\n+        final updates = <String, Map<String, double>>{};\r\n+\r\n+        if (temperature != null) {\r\n+          updates['Reaction Chamber'] = {'temperature': temperature};\r\n+          await _waitForTemperatureStabilization('Reaction Chamber', temperature);\r\n+        }\r\n+\r\n+        if (pressure != null) {\r\n+          updates['Pressure Control System'] = {'pressure': pressure};\r\n+          await _waitForPressureStabilization(pressure);\r\n+        }\r\n+\r\n+        if (updates.isNotEmpty) {\r\n+          _systemStateBloc.add(UpdateSystemParameters(updates));\r\n+        }\r\n+      }\r\n+\r\n+      // Execute loop iterations\r\n+      for (int i = 0; i < iterations; i++) {\r\n+        if (state.executionStatus != RecipeExecutionStatus.running) {\r\n+          break;\r\n+        }\r\n+\r\n+        emit(state.copyWith(\r\n+          currentStepIndex: state.currentStepIndex,\r\n+          executionStatus: RecipeExecutionStatus.running,\r\n+        ));\r\n+\r\n+        for (final subStep in subSteps) {\r\n+          await _executeStep(subStep, emit);\r\n+        }\r\n+      }\r\n+    } catch (error) {\r\n+      _alarmBloc.add(AddAlarm(\r\n+        message: 'Error in loop execution: ${error.toString()}',\r\n+        severity: AlarmSeverity.critical,\r\n+      ));\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _executeSetParameterStep(RecipeStep step) async {\r\n+    final componentName = step.parameters['component'] as String;\r\n+    final parameter = step.parameters['parameter'] as String;\r\n+    final value = step.parameters['value'] as double;\r\n+\r\n+    try {\r\n+      _systemStateBloc.add(UpdateSystemParameters({\r\n+        componentName: {parameter: value},\r\n+      }));\r\n+\r\n+      // Wait for parameter to stabilize\r\n+      await _waitForParameterStabilization(\r\n+        componentName,\r\n+        parameter,\r\n+        value,\r\n+      );\r\n+    } catch (error) {\r\n+      _alarmBloc.add(AddAlarm(\r\n+        message: 'Error setting parameter $parameter for $componentName: ${error.toString()}',\r\n+        severity: AlarmSeverity.critical,\r\n+      ));\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  // Helper methods for parameter stabilization\r\n+  Future<void> _waitForTemperatureStabilization(\r\n+    String componentName,\r\n+    double targetTemperature,\r\n+  ) async {\r\n+    const tolerance = 2.0; // °C\r\n+    const timeout = Duration(minutes: 5);\r\n+    final stopwatch = Stopwatch()..start();\r\n+\r\n+    while (stopwatch.elapsed < timeout) {\r\n+      final currentTemp = _getCurrentValue(componentName, 'temperature');\r\n+      if ((currentTemp - targetTemperature).abs() <= tolerance) {\r\n+        return;\r\n+      }\r\n+      await Future.delayed(const Duration(seconds: 1));\r\n+    }\r\n+    throw Exception('Temperature stabilization timeout');\r\n+  }\r\n+\r\n+  Future<void> _waitForPressureStabilization(double targetPressure) async {\r\n+    const tolerance = 0.05; // atm\r\n+    const timeout = Duration(minutes: 2);\r\n+    final stopwatch = Stopwatch()..start();\r\n+\r\n+    while (stopwatch.elapsed < timeout) {\r\n+      final currentPressure = _getCurrentValue('Pressure Control System', 'pressure');\r\n+      if ((currentPressure - targetPressure).abs() <= tolerance) {\r\n+        return;\r\n+      }\r\n+      await Future.delayed(const Duration(seconds: 1));\r\n+    }\r\n+    throw Exception('Pressure stabilization timeout');\r\n+  }\r\n+\r\n+  Future<void> _waitForParameterStabilization(\r\n+    String componentName,\r\n+    String parameter,\r\n+    double targetValue,\r\n+  ) async {\r\n+    final tolerance = _getToleranceForParameter(parameter);\r\n+    const timeout = Duration(minutes: 2);\r\n+    final stopwatch = Stopwatch()..start();\r\n+\r\n+    while (stopwatch.elapsed < timeout) {\r\n+      final currentValue = _getCurrentValue(componentName, parameter);\r\n+      if ((currentValue - targetValue).abs() <= tolerance) {\r\n+        return;\r\n+      }\r\n+      await Future.delayed(const Duration(seconds: 1));\r\n+    }\r\n+    throw Exception('Parameter stabilization timeout: $parameter');\r\n+  }\r\n+\r\n+  double _getToleranceForParameter(String parameter) {\r\n+    switch (parameter) {\r\n+      case 'temperature': return 2.0;\r\n+      case 'pressure': return 0.05;\r\n+      case 'flow_rate': return 1.0;\r\n+      default: return 0.1;\r\n+    }\r\n+  }\r\n+\r\n+  double _getCurrentValue(String componentName, String parameter) {\r\n+    // Get current value from system state\r\n+    final components = _systemStateBloc.state.currentSystemState['components']\r\n+        as Map<String, dynamic>?;\r\n+\r\n+    if (components == null) {\r\n+      throw Exception('No components found in system state');\r\n+    }\r\n+\r\n+    final component = components[componentName] as Map<String, dynamic>?;\r\n+    if (component == null) {\r\n+      throw Exception('Component not found: $componentName');\r\n+    }\r\n+\r\n+    final currentValues = component['currentValues'] as Map<String, dynamic>?;\r\n+    if (currentValues == null) {\r\n+      throw Exception('No current values for component: $componentName');\r\n+    }\r\n+\r\n+    final value = currentValues[parameter] as double?;\r\n+    if (value == null) {\r\n+      throw Exception('Parameter not found: $parameter');\r\n+    }\r\n+\r\n+    return value;\r\n+  }\r\n+\r\n+  @override\r\n+  Future<void> close() async {\r\n+    await _userSubscription?.cancel();\r\n+    _executionTimer?.cancel();\r\n+    return super.close();\r\n+  }\r\n+  Future<void> _onAddRecipe(\r\n+    AddRecipe event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      await _repository.add(event.recipe.id, event.recipe, userId: userId);\r\n+\r\n+      final updatedRecipes = [...state.recipes, event.recipe];\r\n+      emit(state.copyWith(\r\n+        recipes: updatedRecipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onUpdateRecipe(\r\n+    UpdateRecipe event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      await _repository.update(event.recipe.id, event.recipe, userId: userId);\r\n+\r\n+      final updatedRecipes = state.recipes.map((recipe) =>\r\n+        recipe.id == event.recipe.id ? event.recipe : recipe\r\n+      ).toList();\r\n+\r\n+      emit(state.copyWith(\r\n+        recipes: updatedRecipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onDeleteRecipe(\r\n+    DeleteRecipe event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      await _repository.delete(event.recipeId, userId: userId);\r\n+\r\n+      final updatedRecipes = state.recipes\r\n+          .where((recipe) => recipe.id != event.recipeId)\r\n+          .toList();\r\n+\r\n+      emit(state.copyWith(\r\n+        recipes: updatedRecipes,\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onPauseRecipeExecution(\r\n+    PauseRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    if (state.executionStatus != RecipeExecutionStatus.running) {\r\n+      return;\r\n+    }\r\n+\r\n+    _executionTimer?.cancel();\r\n+    emit(state.copyWith(\r\n+      executionStatus: RecipeExecutionStatus.paused,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onResumeRecipeExecution(\r\n+    ResumeRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    if (state.executionStatus != RecipeExecutionStatus.paused) {\r\n+      return;\r\n+    }\r\n+\r\n+    emit(state.copyWith(\r\n+      executionStatus: RecipeExecutionStatus.running,\r\n+    ));\r\n+\r\n+    if (state.activeRecipe != null) {\r\n+      await _executeStep(\r\n+        state.activeRecipe!.steps[state.currentStepIndex],\r\n+        emit,\r\n+      );\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onStopRecipeExecution(\r\n+    StopRecipeExecution event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      _executionTimer?.cancel();\r\n+      _executionTimer = null;\r\n+\r\n+      _systemStateBloc.add(StopSystem());\r\n+\r\n+      emit(RecipeState.initial()); // Reset to initial state instead of using copyWith\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onRecipeStepCompleted(\r\n+    RecipeStepCompleted event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    if (state.activeRecipe == null ||\r\n+        state.executionStatus != RecipeExecutionStatus.running) {\r\n+      return;\r\n+    }\r\n+\r\n+    final nextStepIndex = event.stepIndex + 1;\r\n+    if (nextStepIndex >= state.activeRecipe!.steps.length) {\r\n+      // Recipe completed\r\n+      emit(state.copyWith(\r\n+        executionStatus: RecipeExecutionStatus.completed,\r\n+        currentStepIndex: 0,\r\n+      ));\r\n+      _systemStateBloc.add(StopSystem());\r\n+      return;\r\n+    }\r\n+\r\n+    emit(state.copyWith(currentStepIndex: nextStepIndex));\r\n+    await _executeStep(\r\n+      state.activeRecipe!.steps[nextStepIndex],\r\n+      emit,\r\n+    );\r\n+  }\r\n+\r\n+  Future<void> _onLoadRecipeVersions(\r\n+    LoadRecipeVersions event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      emit(state.copyWith(isLoading: true));\r\n+\r\n+      final userId = _authService.currentUserId;\r\n+      if (userId == null) {\r\n+        emit(state.copyWith(\r\n+          error: 'User not authenticated',\r\n+          isLoading: false,\r\n+        ));\r\n+        return;\r\n+      }\r\n+\r\n+      final versions = await _repository.getAll(userId: userId);\r\n+      final recipeVersions = versions\r\n+          .where((recipe) => recipe.id == event.recipeId)\r\n+          .toList()\r\n+        ..sort((a, b) => b.version.compareTo(a.version));\r\n+\r\n+      emit(state.copyWith(\r\n+        recipeVersions: {\r\n+          ...state.recipeVersions,\r\n+          event.recipeId: recipeVersions,\r\n+        },\r\n+        isLoading: false,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+        isLoading: false,\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onCompareRecipeVersions(\r\n+    CompareRecipeVersions event,\r\n+    Emitter<RecipeState> emit,\r\n+  ) async {\r\n+    try {\r\n+      final versions = state.recipeVersions[event.recipeId] ?? [];\r\n+      final versionA = versions.firstWhere((r) => r.version == event.versionA);\r\n+      final versionB = versions.firstWhere((r) => r.version == event.versionB);\r\n+\r\n+      final comparison = _compareRecipes(versionA, versionB);\r\n+\r\n+      emit(state.copyWith(\r\n+        versionComparison: comparison,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Map<String, dynamic> _compareRecipes(Recipe oldVersion, Recipe newVersion) {\r\n+    final differences = <String, dynamic>{};\r\n+\r\n+    if (oldVersion.name != newVersion.name) {\r\n+      differences['name'] = {\r\n+        'old': oldVersion.name,\r\n+        'new': newVersion.name,\r\n+      };\r\n+    }\r\n+\r\n+    if (oldVersion.substrate != newVersion.substrate) {\r\n+      differences['substrate'] = {\r\n+        'old': oldVersion.substrate,\r\n+        'new': newVersion.substrate,\r\n+      };\r\n+    }\r\n+\r\n+    differences['steps'] = _compareSteps(oldVersion.steps, newVersion.steps);\r\n+    return differences;\r\n+  }\r\n+\r\n+  List<Map<String, dynamic>> _compareSteps(\r\n+    List<RecipeStep> oldSteps,\r\n+    List<RecipeStep> newSteps,\r\n+  ) {\r\n+    final differences = <Map<String, dynamic>>[];\r\n+    final maxLength = oldSteps.length > newSteps.length\r\n+        ? oldSteps.length\r\n+        : newSteps.length;\r\n+\r\n+    for (var i = 0; i < maxLength; i++) {\r\n+      if (i < oldSteps.length && i < newSteps.length) {\r\n+        if (!_areStepsEqual(oldSteps[i], newSteps[i])) {\r\n+          differences.add({\r\n+            'index': i,\r\n+            'old': _stepToString(oldSteps[i]),\r\n+            'new': _stepToString(newSteps[i]),\r\n+          });\r\n+        }\r\n+      } else if (i < oldSteps.length) {\r\n+        differences.add({\r\n+          'index': i,\r\n+          'old': _stepToString(oldSteps[i]),\r\n+          'new': null,\r\n+        });\r\n+      } else {\r\n+        differences.add({\r\n+          'index': i,\r\n+          'old': null,\r\n+          'new': _stepToString(newSteps[i]),\r\n+        });\r\n+      }\r\n+    }\r\n+\r\n+    return differences;\r\n+  }\r\n+\r\n+  bool _areStepsEqual(RecipeStep step1, RecipeStep step2) {\r\n+    return step1.type == step2.type &&\r\n+           _areParametersEqual(step1.parameters, step2.parameters);\r\n+  }\r\n+\r\n+  bool _areParametersEqual(\r\n+    Map<String, dynamic> params1,\r\n+    Map<String, dynamic> params2,\r\n+  ) {\r\n+    return params1.length == params2.length &&\r\n+           params1.entries.every((entry) =>\r\n+             params2.containsKey(entry.key) &&\r\n+             params2[entry.key] == entry.value);\r\n+  }\r\n+\r\n+  String _stepToString(RecipeStep step) {\r\n+    switch (step.type) {\r\n+      case StepType.loop:\r\n+        return 'Loop ${step.parameters['iterations']} times';\r\n+      case StepType.valve:\r\n+        return '${step.parameters['valveType'] == ValveType.valveA ? 'Valve A' : 'Valve B'} '\r\n+               'for ${step.parameters['duration']}s';\r\n+      case StepType.purge:\r\n+        return 'Purge for ${step.parameters['duration']}s';\r\n+      case StepType.setParameter:\r\n+        return 'Set ${step.parameters['component']} ${step.parameters['parameter']} '\r\n+               'to ${step.parameters['value']}';\r\n+    }\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734433256852,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,29 +6,28 @@\n import 'package:experiment_planner/features/alarms/models/alarm.dart';\r\n import 'package:experiment_planner/features/recipes/models/recipe.dart';\r\n import 'package:experiment_planner/features/recipes/repository/recipe_repository.dart';\r\n import 'package:experiment_planner/features/system/bloc/system_state_event.dart';\r\n-import '../../auth/services/auth_service.dart';\r\n import '../../system/bloc/system_state_bloc.dart';\r\n import 'recipe_event.dart';\r\n import 'recipe_state.dart';\r\n import '../models/recipe_validation_result.dart';\r\n \r\n class RecipeBloc extends Bloc<RecipeEvent, RecipeState> {\r\n   final RecipeRepository _repository;\r\n-  final AuthService _authService;\r\n+  final AuthBloc _authBloc;\r\n   final SystemStateBloc _systemStateBloc;\r\n   final AlarmBloc _alarmBloc;\r\n   Timer? _executionTimer;\r\n-  StreamSubscription? _userSubscription;\r\n+  StreamSubscription? _authSubscription;\r\n \r\n   RecipeBloc({\r\n     required RecipeRepository repository,\r\n-    required AuthService authService,\r\n+    required AuthBloc authBloc,\r\n     required SystemStateBloc systemStateBloc,\r\n     required AlarmBloc alarmBloc,\r\n   })  : _repository = repository,\r\n-        _authService = authService,\r\n+        _authBloc = authBloc,\r\n         _systemStateBloc = systemStateBloc,\r\n         _alarmBloc = alarmBloc,\r\n         super(RecipeState.initial()) {\r\n     on<LoadRecipes>(_onLoadRecipes);\r\n@@ -42,18 +41,19 @@\n     on<RecipeStepCompleted>(_onRecipeStepCompleted);\r\n     on<LoadRecipeVersions>(_onLoadRecipeVersions);\r\n     on<CompareRecipeVersions>(_onCompareRecipeVersions);\r\n \r\n-    // Add user subscription\r\n-    _userSubscription = _authService.onUserChanged.listen((userId) {\r\n-      if (userId != null) {\r\n+    _authSubscription = _authBloc.stream.listen((authState) {\r\n+      if (authState.status == AuthStatus.authenticated) {\r\n         add(LoadRecipes());\r\n-      } else {\r\n+      } else if (authState.status == AuthStatus.unauthenticated) {\r\n         emit(RecipeState.initial());\r\n       }\r\n     });\r\n   }\r\n \r\n+  String? get _currentUserId => _authBloc.state.user?.id;\r\n+\r\n   RecipeValidationResult _validateRecipe(Recipe recipe) {\r\n     final errors = <String>[];\r\n \r\n     // Validate basic recipe properties\r\n@@ -215,9 +215,9 @@\n   ) async {\r\n     try {\r\n       emit(state.copyWith(isLoading: true));\r\n \r\n-      final userId = _authService.currentUserId;\r\n+      final userId = _currentUserId;\r\n       if (userId == null) {\r\n         emit(state.copyWith(\r\n           error: 'User not authenticated',\r\n           isLoading: false,\r\n@@ -531,9 +531,9 @@\n   }\r\n \r\n   @override\r\n   Future<void> close() async {\r\n-    await _userSubscription?.cancel();\r\n+    await _authSubscription?.cancel();\r\n     _executionTimer?.cancel();\r\n     return super.close();\r\n   }\r\n   Future<void> _onAddRecipe(\r\n@@ -542,9 +542,9 @@\n   ) async {\r\n     try {\r\n       emit(state.copyWith(isLoading: true));\r\n \r\n-      final userId = _authService.currentUserId;\r\n+      final userId = _currentUserId;\r\n       if (userId == null) {\r\n         emit(state.copyWith(\r\n           error: 'User not authenticated',\r\n           isLoading: false,\r\n@@ -573,9 +573,9 @@\n   ) async {\r\n     try {\r\n       emit(state.copyWith(isLoading: true));\r\n \r\n-      final userId = _authService.currentUserId;\r\n+      final userId = _currentUserId;\r\n       if (userId == null) {\r\n         emit(state.copyWith(\r\n           error: 'User not authenticated',\r\n           isLoading: false,\r\n@@ -607,9 +607,9 @@\n   ) async {\r\n     try {\r\n       emit(state.copyWith(isLoading: true));\r\n \r\n-      final userId = _authService.currentUserId;\r\n+      final userId = _currentUserId;\r\n       if (userId == null) {\r\n         emit(state.copyWith(\r\n           error: 'User not authenticated',\r\n           isLoading: false,\r\n@@ -720,9 +720,9 @@\n   ) async {\r\n     try {\r\n       emit(state.copyWith(isLoading: true));\r\n \r\n-      final userId = _authService.currentUserId;\r\n+      final userId = _currentUserId;\r\n       if (userId == null) {\r\n         emit(state.copyWith(\r\n           error: 'User not authenticated',\r\n           isLoading: false,\r\n"
                },
                {
                    "date": 1734433263246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -855,5 +855,9 @@\n                'for ${step.parameters['duration']}s';\r\n       case StepType.purge:\r\n         return 'Purge for ${step.parameters['duration']}s';\r\n       case StepType.setParameter:\r\n-        return 'Set ${step.parameters['component']} ${step.parameters['parame\n\\ No newline at end of file\n+        return 'Set ${step.parameters['component']} ${step.parameters['parameter']} '\r\n+               'to ${step.parameters['value']}';\r\n+    }\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1734376760280,
            "name": "Commit-0",
            "content": "\r\nimport 'dart:async';\r\nimport 'package:bloc/bloc.dart';\r\nimport 'package:experiment_planner/blocs/alarm/bloc/alarm_event.dart';\r\nimport 'package:experiment_planner/blocs/recipe/repository/recipe_repository.dart';\r\nimport 'package:experiment_planner/blocs/system_state/bloc/system_state_event.dart';\r\nimport 'package:experiment_planner/features/alarms/models/alarm.dart';\r\nimport 'package:experiment_planner/features/recipes/models/recipe.dart';\r\nimport '../../auth/services/auth_service.dart';\r\nimport '../../system/bloc/system_state_bloc.dart';\r\nimport '../../alarm/bloc/alarm_bloc.dart';\r\nimport '../../utils/bloc_utils.dart';\r\nimport 'recipe_event.dart';\r\nimport 'recipe_state.dart';\r\nimport '../models/recipe_validation_result.dart';\r\n\r\nclass RecipeBloc extends Bloc<RecipeEvent, RecipeState> {\r\n  final RecipeRepository _repository;\r\n  final AuthService _authService;\r\n  final SystemStateBloc _systemStateBloc;\r\n  final AlarmBloc _alarmBloc;\r\n  Timer? _executionTimer;\r\n\r\n  RecipeBloc({\r\n    required RecipeRepository repository,\r\n    required AuthService authService,\r\n    required SystemStateBloc systemStateBloc,\r\n    required AlarmBloc alarmBloc,\r\n  })  : _repository = repository,\r\n        _authService = authService,\r\n        _systemStateBloc = systemStateBloc,\r\n        _alarmBloc = alarmBloc,\r\n        super(RecipeState.initial()) {\r\n    on<LoadRecipes>(_onLoadRecipes);\r\n    on<AddRecipe>(_onAddRecipe);\r\n    on<UpdateRecipe>(_onUpdateRecipe);\r\n    on<DeleteRecipe>(_onDeleteRecipe);\r\n    on<StartRecipeExecution>(_onStartRecipeExecution);\r\n    on<PauseRecipeExecution>(_onPauseRecipeExecution);\r\n    on<ResumeRecipeExecution>(_onResumeRecipeExecution);\r\n    on<StopRecipeExecution>(_onStopRecipeExecution);\r\n    on<RecipeStepCompleted>(_onRecipeStepCompleted);\r\n    on<LoadRecipeVersions>(_onLoadRecipeVersions);\r\n    on<CompareRecipeVersions>(_onCompareRecipeVersions);\r\n  }\r\n\r\n  RecipeValidationResult _validateRecipe(Recipe recipe) {\r\n    final errors = <String>[];\r\n\r\n    // Validate basic recipe properties\r\n    if (recipe.name.isEmpty) {\r\n      errors.add('Recipe name is required');\r\n    }\r\n    if (recipe.substrate.isEmpty) {\r\n      errors.add('Substrate is required');\r\n    }\r\n    if (recipe.steps.isEmpty) {\r\n      errors.add('Recipe must have at least one step');\r\n    }\r\n\r\n    // Validate each step\r\n    for (int i = 0; i < recipe.steps.length; i++) {\r\n      final stepErrors = _validateStep(recipe.steps[i], i);\r\n      errors.addAll(stepErrors);\r\n    }\r\n\r\n    return RecipeValidationResult(\r\n      isValid: errors.isEmpty,\r\n      errors: errors,\r\n    );\r\n  }\r\n\r\n  List<String> _validateStep(RecipeStep step, int index) {\r\n    final errors = <String>[];\r\n    final prefix = 'Step ${index + 1}';\r\n\r\n    switch (step.type) {\r\n      case StepType.valve:\r\n        if (!step.parameters.containsKey('duration')) {\r\n          errors.add('$prefix: Valve duration is required');\r\n        } else if (step.parameters['duration'] <= 0) {\r\n          errors.add('$prefix: Valve duration must be positive');\r\n        }\r\n        if (!step.parameters.containsKey('valveType')) {\r\n          errors.add('$prefix: Valve type is required');\r\n        }\r\n        break;\r\n\r\n      case StepType.purge:\r\n        if (!step.parameters.containsKey('duration')) {\r\n          errors.add('$prefix: Purge duration is required');\r\n        } else if (step.parameters['duration'] <= 0) {\r\n          errors.add('$prefix: Purge duration must be positive');\r\n        }\r\n        break;\r\n\r\n      case StepType.loop:\r\n        if (!step.parameters.containsKey('iterations')) {\r\n          errors.add('$prefix: Loop iterations is required');\r\n        } else if (step.parameters['iterations'] <= 0) {\r\n          errors.add('$prefix: Loop iterations must be positive');\r\n        }\r\n        if (step.subSteps == null || step.subSteps!.isEmpty) {\r\n          errors.add('$prefix: Loop must contain substeps');\r\n        } else {\r\n          for (int i = 0; i < step.subSteps!.length; i++) {\r\n            final substepErrors = _validateStep(step.subSteps![i], i);\r\n            errors.addAll(substepErrors.map((e) => '$prefix (Substep ${i + 1}): $e'));\r\n          }\r\n        }\r\n        break;\r\n\r\n      case StepType.setParameter:\r\n        if (!step.parameters.containsKey('component')) {\r\n          errors.add('$prefix: Component name is required');\r\n        }\r\n        if (!step.parameters.containsKey('parameter')) {\r\n          errors.add('$prefix: Parameter name is required');\r\n        }\r\n        if (!step.parameters.containsKey('value')) {\r\n          errors.add('$prefix: Parameter value is required');\r\n        }\r\n        break;\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  Future<bool> _handleStepError(\r\n    RecipeStep step,\r\n    dynamic error,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    final errorMessage = error.toString();\r\n\r\n    _alarmBloc.add(AddAlarm(\r\n      message: 'Error executing step: $errorMessage',\r\n      severity: AlarmSeverity.critical,\r\n    ));\r\n\r\n    switch (step.type) {\r\n      case StepType.valve:\r\n        return await _recoverValveError(step);\r\n      case StepType.purge:\r\n        return await _recoverPurgeError(step);\r\n      case StepType.setParameter:\r\n        return await _recoverParameterError(step);\r\n      case StepType.loop:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  Future<bool> _recoverValveError(RecipeStep step) async {\r\n    try {\r\n      _systemStateBloc.add(UpdateSystemParameters({\r\n        'Valve 1': {'status': 0.0},\r\n        'Valve 2': {'status': 0.0},\r\n      }));\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  Future<bool> _recoverPurgeError(RecipeStep step) async {\r\n    try {\r\n      _systemStateBloc.add(UpdateSystemParameters({\r\n        'MFC': {'flow_rate': 0.0},\r\n        'Valve 1': {'status': 0.0},\r\n        'Valve 2': {'status': 0.0},\r\n      }));\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  Future<bool> _recoverParameterError(RecipeStep step) async {\r\n    try {\r\n      final componentName = step.parameters['component'] as String;\r\n      final parameter = step.parameters['parameter'] as String;\r\n\r\n      switch (parameter) {\r\n        case 'temperature':\r\n          _systemStateBloc.add(UpdateSystemParameters({\r\n            componentName: {'temperature': 25.0},\r\n          }));\r\n          break;\r\n        case 'pressure':\r\n          _systemStateBloc.add(UpdateSystemParameters({\r\n            componentName: {'pressure': 1.0},\r\n          }));\r\n          break;\r\n        default:\r\n          return false;\r\n      }\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  Future<void> _onLoadRecipes(\r\n    LoadRecipes event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      final userId = _authService.currentUserId;\r\n      if (userId == null) {\r\n        emit(state.copyWith(\r\n          error: 'User not authenticated',\r\n          isLoading: false,\r\n        ));\r\n        return;\r\n      }\r\n\r\n      final recipes = await _repository.getAll(userId: userId);\r\n      emit(state.copyWith(\r\n        recipes: recipes,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onStartRecipeExecution(\r\n    StartRecipeExecution event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      final recipe = state.recipes.firstWhere(\r\n        (r) => r.id == event.recipeId,\r\n        orElse: () => throw Exception('Recipe not found'),\r\n      );\r\n\r\n      // Add validation\r\n      final validation = _validateRecipe(recipe);\r\n      if (!validation.isValid) {\r\n        throw Exception('Invalid recipe: ${validation.errors.join(', ')}');\r\n      }\r\n\r\n      // Check system readiness\r\n      _systemStateBloc.add(CheckSystemReadiness());\r\n      if (!_systemStateBloc.state.isReadinessCheckPassed) {\r\n        throw Exception('System not ready for recipe execution');\r\n      }\r\n\r\n      // Start system if not running\r\n      if (!_systemStateBloc.state.isSystemRunning) {\r\n        _systemStateBloc.add(StartSystem());\r\n      }\r\n\r\n      emit(state.copyWith(\r\n        activeRecipe: recipe,\r\n        currentStepIndex: 0,\r\n        executionStatus: RecipeExecutionStatus.running,\r\n      ));\r\n\r\n      // Execute first step\r\n      await _executeStep(recipe.steps[0], emit);\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        executionStatus: RecipeExecutionStatus.error,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _executeStep(RecipeStep step, Emitter<RecipeState> emit) async {\r\n    try {\r\n      switch (step.type) {\r\n        case StepType.valve:\r\n          await _executeValveStep(step);\r\n          break;\r\n        case StepType.purge:\r\n          await _executePurgeStep(step);\r\n          break;\r\n        case StepType.loop:\r\n          await _executeLoopStep(step, emit);\r\n          break;\r\n        case StepType.setParameter:\r\n          await _executeSetParameterStep(step);\r\n          break;\r\n      }\r\n    } catch (error) {\r\n      // Add error recovery\r\n      final recovered = await _handleStepError(step, error, emit);\r\n      if (!recovered) {\r\n        _alarmBloc.add(AddAlarm(\r\n          message: 'Unrecoverable error in recipe execution: ${error.toString()}',\r\n          severity: AlarmSeverity.critical,\r\n        ));\r\n        emit(state.copyWith(\r\n          executionStatus: RecipeExecutionStatus.error,\r\n          error: error.toString(),\r\n        ));\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  Future<void> _executeValveStep(RecipeStep step) async {\r\n    final componentName = step.parameters['valveType'] == ValveType.valveA\r\n        ? 'Valve 1'\r\n        : 'Valve 2';\r\n    final duration = step.parameters['duration'] as int;\r\n\r\n    _systemStateBloc.add(UpdateSystemParameters({\r\n      componentName: {'status': 1.0},\r\n    }));\r\n\r\n    await Future.delayed(Duration(seconds: duration));\r\n\r\n    _systemStateBloc.add(UpdateSystemParameters({\r\n      componentName: {'status': 0.0},\r\n    }));\r\n  }\r\n\r\n    Future<void> _executePurgeStep(RecipeStep step) async {\r\n    final duration = step.parameters['duration'] as int;\r\n    final gasFlow = step.parameters['gasFlow'] as double? ?? 100.0;\r\n\r\n    try {\r\n      // Close valves\r\n      _systemStateBloc.add(UpdateSystemParameters({\r\n        'Valve 1': {'status': 0.0},\r\n        'Valve 2': {'status': 0.0},\r\n      }));\r\n\r\n      // Set MFC to purge flow rate\r\n      _systemStateBloc.add(UpdateSystemParameters({\r\n        'MFC': {'flow_rate': gasFlow},\r\n      }));\r\n\r\n      await Future.delayed(Duration(seconds: duration));\r\n\r\n      // Reset MFC flow rate\r\n      _systemStateBloc.add(UpdateSystemParameters({\r\n        'MFC': {'flow_rate': 0.0},\r\n      }));\r\n    } catch (error) {\r\n      _alarmBloc.add(AddAlarm(\r\n        message: 'Error during purge step: ${error.toString()}',\r\n        severity: AlarmSeverity.critical,\r\n      ));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  Future<void> _executeLoopStep(RecipeStep step, Emitter<RecipeState> emit) async {\r\n    final iterations = step.parameters['iterations'] as int;\r\n    final temperature = step.parameters['temperature'] as double?;\r\n    final pressure = step.parameters['pressure'] as double?;\r\n    final subSteps = step.subSteps;\r\n\r\n    if (subSteps == null || subSteps.isEmpty) {\r\n      throw Exception('Loop step has no substeps');\r\n    }\r\n\r\n    try {\r\n      // Set chamber parameters if specified\r\n      if (temperature != null || pressure != null) {\r\n        final updates = <String, Map<String, double>>{};\r\n\r\n        if (temperature != null) {\r\n          updates['Reaction Chamber'] = {'temperature': temperature};\r\n          await _waitForTemperatureStabilization('Reaction Chamber', temperature);\r\n        }\r\n\r\n        if (pressure != null) {\r\n          updates['Pressure Control System'] = {'pressure': pressure};\r\n          await _waitForPressureStabilization(pressure);\r\n        }\r\n\r\n        if (updates.isNotEmpty) {\r\n          _systemStateBloc.add(UpdateSystemParameters(updates));\r\n        }\r\n      }\r\n\r\n      // Execute loop iterations\r\n      for (int i = 0; i < iterations; i++) {\r\n        if (state.executionStatus != RecipeExecutionStatus.running) {\r\n          break;\r\n        }\r\n\r\n        emit(state.copyWith(\r\n          currentStepIndex: state.currentStepIndex,\r\n          executionStatus: RecipeExecutionStatus.running,\r\n        ));\r\n\r\n        for (final subStep in subSteps) {\r\n          await _executeStep(subStep, emit);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      _alarmBloc.add(AddAlarm(\r\n        message: 'Error in loop execution: ${error.toString()}',\r\n        severity: AlarmSeverity.critical,\r\n      ));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  Future<void> _executeSetParameterStep(RecipeStep step) async {\r\n    final componentName = step.parameters['component'] as String;\r\n    final parameter = step.parameters['parameter'] as String;\r\n    final value = step.parameters['value'] as double;\r\n\r\n    try {\r\n      _systemStateBloc.add(UpdateSystemParameters({\r\n        componentName: {parameter: value},\r\n      }));\r\n\r\n      // Wait for parameter to stabilize\r\n      await _waitForParameterStabilization(\r\n        componentName,\r\n        parameter,\r\n        value,\r\n      );\r\n    } catch (error) {\r\n      _alarmBloc.add(AddAlarm(\r\n        message: 'Error setting parameter $parameter for $componentName: ${error.toString()}',\r\n        severity: AlarmSeverity.critical,\r\n      ));\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Helper methods for parameter stabilization\r\n  Future<void> _waitForTemperatureStabilization(\r\n    String componentName,\r\n    double targetTemperature,\r\n  ) async {\r\n    const tolerance = 2.0; // °C\r\n    const timeout = Duration(minutes: 5);\r\n    final stopwatch = Stopwatch()..start();\r\n\r\n    while (stopwatch.elapsed < timeout) {\r\n      final currentTemp = _getCurrentValue(componentName, 'temperature');\r\n      if ((currentTemp - targetTemperature).abs() <= tolerance) {\r\n        return;\r\n      }\r\n      await Future.delayed(const Duration(seconds: 1));\r\n    }\r\n    throw Exception('Temperature stabilization timeout');\r\n  }\r\n\r\n  Future<void> _waitForPressureStabilization(double targetPressure) async {\r\n    const tolerance = 0.05; // atm\r\n    const timeout = Duration(minutes: 2);\r\n    final stopwatch = Stopwatch()..start();\r\n\r\n    while (stopwatch.elapsed < timeout) {\r\n      final currentPressure = _getCurrentValue('Pressure Control System', 'pressure');\r\n      if ((currentPressure - targetPressure).abs() <= tolerance) {\r\n        return;\r\n      }\r\n      await Future.delayed(const Duration(seconds: 1));\r\n    }\r\n    throw Exception('Pressure stabilization timeout');\r\n  }\r\n\r\n  Future<void> _waitForParameterStabilization(\r\n    String componentName,\r\n    String parameter,\r\n    double targetValue,\r\n  ) async {\r\n    final tolerance = _getToleranceForParameter(parameter);\r\n    const timeout = Duration(minutes: 2);\r\n    final stopwatch = Stopwatch()..start();\r\n\r\n    while (stopwatch.elapsed < timeout) {\r\n      final currentValue = _getCurrentValue(componentName, parameter);\r\n      if ((currentValue - targetValue).abs() <= tolerance) {\r\n        return;\r\n      }\r\n      await Future.delayed(const Duration(seconds: 1));\r\n    }\r\n    throw Exception('Parameter stabilization timeout: $parameter');\r\n  }\r\n\r\n  double _getToleranceForParameter(String parameter) {\r\n    switch (parameter) {\r\n      case 'temperature': return 2.0;\r\n      case 'pressure': return 0.05;\r\n      case 'flow_rate': return 1.0;\r\n      default: return 0.1;\r\n    }\r\n  }\r\n\r\n  double _getCurrentValue(String componentName, String parameter) {\r\n    // Get current value from system state\r\n    final components = _systemStateBloc.state.currentSystemState['components']\r\n        as Map<String, dynamic>?;\r\n\r\n    if (components == null) {\r\n      throw Exception('No components found in system state');\r\n    }\r\n\r\n    final component = components[componentName] as Map<String, dynamic>?;\r\n    if (component == null) {\r\n      throw Exception('Component not found: $componentName');\r\n    }\r\n\r\n    final currentValues = component['currentValues'] as Map<String, dynamic>?;\r\n    if (currentValues == null) {\r\n      throw Exception('No current values for component: $componentName');\r\n    }\r\n\r\n    final value = currentValues[parameter] as double?;\r\n    if (value == null) {\r\n      throw Exception('Parameter not found: $parameter');\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  @override\r\n  Future<void> close() async {\r\n    _executionTimer?.cancel();\r\n    return super.close();\r\n  }\r\n  Future<void> _onAddRecipe(\r\n    AddRecipe event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      final userId = _authService.currentUserId;\r\n      if (userId == null) {\r\n        emit(state.copyWith(\r\n          error: 'User not authenticated',\r\n          isLoading: false,\r\n        ));\r\n        return;\r\n      }\r\n\r\n      await _repository.add(event.recipe.id, event.recipe, userId: userId);\r\n\r\n      final updatedRecipes = [...state.recipes, event.recipe];\r\n      emit(state.copyWith(\r\n        recipes: updatedRecipes,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onUpdateRecipe(\r\n    UpdateRecipe event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      final userId = _authService.currentUserId;\r\n      if (userId == null) {\r\n        emit(state.copyWith(\r\n          error: 'User not authenticated',\r\n          isLoading: false,\r\n        ));\r\n        return;\r\n      }\r\n\r\n      await _repository.update(event.recipe.id, event.recipe, userId: userId);\r\n\r\n      final updatedRecipes = state.recipes.map((recipe) =>\r\n        recipe.id == event.recipe.id ? event.recipe : recipe\r\n      ).toList();\r\n\r\n      emit(state.copyWith(\r\n        recipes: updatedRecipes,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onDeleteRecipe(\r\n    DeleteRecipe event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      final userId = _authService.currentUserId;\r\n      if (userId == null) {\r\n        emit(state.copyWith(\r\n          error: 'User not authenticated',\r\n          isLoading: false,\r\n        ));\r\n        return;\r\n      }\r\n\r\n      await _repository.delete(event.recipeId, userId: userId);\r\n\r\n      final updatedRecipes = state.recipes\r\n          .where((recipe) => recipe.id != event.recipeId)\r\n          .toList();\r\n\r\n      emit(state.copyWith(\r\n        recipes: updatedRecipes,\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onPauseRecipeExecution(\r\n    PauseRecipeExecution event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    if (state.executionStatus != RecipeExecutionStatus.running) {\r\n      return;\r\n    }\r\n\r\n    _executionTimer?.cancel();\r\n    emit(state.copyWith(\r\n      executionStatus: RecipeExecutionStatus.paused,\r\n    ));\r\n  }\r\n\r\n  Future<void> _onResumeRecipeExecution(\r\n    ResumeRecipeExecution event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    if (state.executionStatus != RecipeExecutionStatus.paused) {\r\n      return;\r\n    }\r\n\r\n    emit(state.copyWith(\r\n      executionStatus: RecipeExecutionStatus.running,\r\n    ));\r\n\r\n    if (state.activeRecipe != null) {\r\n      await _executeStep(\r\n        state.activeRecipe!.steps[state.currentStepIndex],\r\n        emit,\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> _onStopRecipeExecution(\r\n    StopRecipeExecution event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      _executionTimer?.cancel();\r\n      _executionTimer = null;\r\n\r\n      _systemStateBloc.add(StopSystem());\r\n\r\n      emit(RecipeState.initial()); // Reset to initial state instead of using copyWith\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onRecipeStepCompleted(\r\n    RecipeStepCompleted event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    if (state.activeRecipe == null ||\r\n        state.executionStatus != RecipeExecutionStatus.running) {\r\n      return;\r\n    }\r\n\r\n    final nextStepIndex = event.stepIndex + 1;\r\n    if (nextStepIndex >= state.activeRecipe!.steps.length) {\r\n      // Recipe completed\r\n      emit(state.copyWith(\r\n        executionStatus: RecipeExecutionStatus.completed,\r\n        currentStepIndex: 0,\r\n      ));\r\n      _systemStateBloc.add(StopSystem());\r\n      return;\r\n    }\r\n\r\n    emit(state.copyWith(currentStepIndex: nextStepIndex));\r\n    await _executeStep(\r\n      state.activeRecipe!.steps[nextStepIndex],\r\n      emit,\r\n    );\r\n  }\r\n\r\n  Future<void> _onLoadRecipeVersions(\r\n    LoadRecipeVersions event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      emit(state.copyWith(isLoading: true));\r\n\r\n      final userId = _authService.currentUserId;\r\n      if (userId == null) {\r\n        emit(state.copyWith(\r\n          error: 'User not authenticated',\r\n          isLoading: false,\r\n        ));\r\n        return;\r\n      }\r\n\r\n      final versions = await _repository.getAll(userId: userId);\r\n      final recipeVersions = versions\r\n          .where((recipe) => recipe.id == event.recipeId)\r\n          .toList()\r\n        ..sort((a, b) => b.version.compareTo(a.version));\r\n\r\n      emit(state.copyWith(\r\n        recipeVersions: {\r\n          ...state.recipeVersions,\r\n          event.recipeId: recipeVersions,\r\n        },\r\n        isLoading: false,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n        isLoading: false,\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onCompareRecipeVersions(\r\n    CompareRecipeVersions event,\r\n    Emitter<RecipeState> emit,\r\n  ) async {\r\n    try {\r\n      final versions = state.recipeVersions[event.recipeId] ?? [];\r\n      final versionA = versions.firstWhere((r) => r.version == event.versionA);\r\n      final versionB = versions.firstWhere((r) => r.version == event.versionB);\r\n\r\n      final comparison = _compareRecipes(versionA, versionB);\r\n\r\n      emit(state.copyWith(\r\n        versionComparison: comparison,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        error: BlocUtils.handleError(error),\r\n      ));\r\n    }\r\n  }\r\n\r\n  Map<String, dynamic> _compareRecipes(Recipe oldVersion, Recipe newVersion) {\r\n    final differences = <String, dynamic>{};\r\n\r\n    if (oldVersion.name != newVersion.name) {\r\n      differences['name'] = {\r\n        'old': oldVersion.name,\r\n        'new': newVersion.name,\r\n      };\r\n    }\r\n\r\n    if (oldVersion.substrate != newVersion.substrate) {\r\n      differences['substrate'] = {\r\n        'old': oldVersion.substrate,\r\n        'new': newVersion.substrate,\r\n      };\r\n    }\r\n\r\n    differences['steps'] = _compareSteps(oldVersion.steps, newVersion.steps);\r\n    return differences;\r\n  }\r\n\r\n  List<Map<String, dynamic>> _compareSteps(\r\n    List<RecipeStep> oldSteps,\r\n    List<RecipeStep> newSteps,\r\n  ) {\r\n    final differences = <Map<String, dynamic>>[];\r\n    final maxLength = oldSteps.length > newSteps.length\r\n        ? oldSteps.length\r\n        : newSteps.length;\r\n\r\n    for (var i = 0; i < maxLength; i++) {\r\n      if (i < oldSteps.length && i < newSteps.length) {\r\n        if (!_areStepsEqual(oldSteps[i], newSteps[i])) {\r\n          differences.add({\r\n            'index': i,\r\n            'old': _stepToString(oldSteps[i]),\r\n            'new': _stepToString(newSteps[i]),\r\n          });\r\n        }\r\n      } else if (i < oldSteps.length) {\r\n        differences.add({\r\n          'index': i,\r\n          'old': _stepToString(oldSteps[i]),\r\n          'new': null,\r\n        });\r\n      } else {\r\n        differences.add({\r\n          'index': i,\r\n          'old': null,\r\n          'new': _stepToString(newSteps[i]),\r\n        });\r\n      }\r\n    }\r\n\r\n    return differences;\r\n  }\r\n\r\n  bool _areStepsEqual(RecipeStep step1, RecipeStep step2) {\r\n    return step1.type == step2.type &&\r\n           _areParametersEqual(step1.parameters, step2.parameters);\r\n  }\r\n\r\n  bool _areParametersEqual(\r\n    Map<String, dynamic> params1,\r\n    Map<String, dynamic> params2,\r\n  ) {\r\n    return params1.length == params2.length &&\r\n           params1.entries.every((entry) =>\r\n             params2.containsKey(entry.key) &&\r\n             params2[entry.key] == entry.value);\r\n  }\r\n\r\n  String _stepToString(RecipeStep step) {\r\n    switch (step.type) {\r\n      case StepType.loop:\r\n        return 'Loop ${step.parameters['iterations']} times';\r\n      case StepType.valve:\r\n        return '${step.parameters['valveType'] == ValveType.valveA ? 'Valve A' : 'Valve B'} '\r\n               'for ${step.parameters['duration']}s';\r\n      case StepType.purge:\r\n        return 'Purge for ${step.parameters['duration']}s';\r\n      case StepType.setParameter:\r\n        return 'Set ${step.parameters['component']} ${step.parameters['parameter']} '\r\n               'to ${step.parameters['value']}';\r\n    }\r\n  }\r\n}"
        }
    ]
}