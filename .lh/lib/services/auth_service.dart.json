{
    "sourceFile": "lib/services/auth_service.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1734284110954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1734284110954,
            "name": "Commit-0",
            "content": "// lib/services/auth_service.dart\r\n\r\nimport 'package:experiment_planner/repositories/machine_serial.dart';\r\nimport 'package:experiment_planner/repositories/user_request_repository.dart';\r\nimport 'package:firebase_auth/firebase_auth.dart';\r\nimport 'package:cloud_firestore/cloud_firestore.dart';\r\nimport '../enums/user_role.dart';\r\n\r\nclass AuthService {\r\n  final FirebaseAuth _auth = FirebaseAuth.instance;\r\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\r\n  final MachineSerialRepository _machineSerialRepository = MachineSerialRepository();\r\n  final UserRequestRepository _userRequestRepository = UserRequestRepository();\r\n\r\n  User? get currentUser => _auth.currentUser;\r\n  String? get currentUserId => _auth.currentUser?.uid;\r\n  Stream<User?> get authStateChanges => _auth.authStateChanges();\r\n\r\n  Future<String?> getUserStatus(String userId) async {\r\n    try {\r\n      DocumentSnapshot doc = await _firestore.collection('users').doc(userId).get();\r\n      if (!doc.exists) return null;\r\n\r\n      String? role = doc.get('role') as String?;\r\n      if (role?.toLowerCase() == 'admin') {\r\n        return 'approved';\r\n      }\r\n      return doc.get('status') as String?;\r\n    } catch (e) {\r\n      throw FirebaseAuthException(\r\n        code: 'status-fetch-error',\r\n        message: 'Error fetching user status: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> updateUserStatus(String userId, String status) async {\r\n    try {\r\n      await _firestore.collection('users').doc(userId).update({\r\n        'status': status,\r\n        'updatedAt': FieldValue.serverTimestamp(),\r\n      });\r\n    } catch (e) {\r\n      throw FirebaseAuthException(\r\n        code: 'status-update-error',\r\n        message: 'Error updating user status: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> updateUserRole(String userId, UserRole role) async {\r\n    try {\r\n      await _firestore.collection('users').doc(userId).update({\r\n        'role': role.toString().split('.').last.toLowerCase(),\r\n        'updatedAt': FieldValue.serverTimestamp(),\r\n      });\r\n    } catch (e) {\r\n      throw FirebaseAuthException(\r\n        code: 'role-update-error',\r\n        message: 'Error updating user role: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> validateUserData(String userId) async {\r\n    try {\r\n      DocumentSnapshot doc = await _firestore.collection('users').doc(userId).get();\r\n      Map<String, dynamic>? data = doc.data() as Map<String, dynamic>?;\r\n\r\n      if (!doc.exists || data == null || !data.containsKey('status') || !data.containsKey('role')) {\r\n        await _firestore.collection('users').doc(userId).set({\r\n          'status': 'pending',\r\n          'role': 'user',\r\n          'updatedAt': FieldValue.serverTimestamp(),\r\n        }, SetOptions(merge: true));\r\n      }\r\n    } catch (e) {\r\n      throw FirebaseAuthException(\r\n        code: 'data-validation-error',\r\n        message: 'Error validating user data: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<UserCredential> signUp({\r\n    required String email,\r\n    required String password,\r\n    required String name,\r\n    required String machineSerial\r\n  }) async {\r\n    try {\r\n      // Validate inputs\r\n      if (email.isEmpty || password.isEmpty || name.isEmpty || machineSerial.isEmpty) {\r\n        throw FirebaseAuthException(\r\n          code: 'invalid-inputs',\r\n          message: 'All fields are required'\r\n        );\r\n      }\r\n\r\n      // Create user account\r\n      UserCredential credential = await _auth.createUserWithEmailAndPassword(\r\n        email: email,\r\n        password: password\r\n      );\r\n\r\n      User? user = credential.user;\r\n      if (user == null) throw Exception('User creation failed');\r\n\r\n      // Create user request\r\n      UserRequest request = UserRequest(\r\n        userId: user.uid,\r\n        email: email,\r\n        name: name,\r\n        machineSerial: machineSerial,\r\n      );\r\n      await _userRequestRepository.createUserRequest(request);\r\n\r\n      // Create user document\r\n      await _firestore.collection('users').doc(user.uid).set({\r\n        'name': name,\r\n        'email': email,\r\n        'machineSerial': machineSerial,\r\n        'status': 'pending',\r\n        'role': 'user',\r\n        'createdAt': FieldValue.serverTimestamp(),\r\n        'updatedAt': FieldValue.serverTimestamp(),\r\n      });\r\n\r\n      // Assign machine\r\n      await _machineSerialRepository.assignUserToMachine(machineSerial, user.uid);\r\n\r\n      return credential;\r\n    } catch (e) {\r\n      if (e is FirebaseAuthException) {\r\n        throw e;\r\n      }\r\n      throw FirebaseAuthException(\r\n        code: 'signup-error',\r\n        message: 'Error during sign up: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<UserCredential> signIn({\r\n    required String email,\r\n    required String password\r\n  }) async {\r\n    try {\r\n      // Validate inputs\r\n      if (email.isEmpty || password.isEmpty) {\r\n        throw FirebaseAuthException(\r\n          code: 'invalid-inputs',\r\n          message: 'Email and password are required'\r\n        );\r\n      }\r\n\r\n      // Sign in user\r\n      UserCredential credential = await _auth.signInWithEmailAndPassword(\r\n        email: email,\r\n        password: password\r\n      );\r\n\r\n      User? user = credential.user;\r\n      if (user == null) throw Exception('Sign in failed');\r\n\r\n      // Check/create user document\r\n      DocumentSnapshot userDoc = await _firestore.collection('users').doc(user.uid).get();\r\n      if (!userDoc.exists) {\r\n        await _firestore.collection('users').doc(user.uid).set({\r\n          'email': user.email,\r\n          'role': 'admin',\r\n          'status': 'approved',\r\n          'createdAt': FieldValue.serverTimestamp(),\r\n          'updatedAt': FieldValue.serverTimestamp(),\r\n        });\r\n      }\r\n\r\n      return credential;\r\n    } catch (e) {\r\n      if (e is FirebaseAuthException) {\r\n        throw e;\r\n      }\r\n      throw FirebaseAuthException(\r\n        code: 'signin-error',\r\n        message: 'Error during sign in: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> signOut() async {\r\n    try {\r\n      await _auth.signOut();\r\n    } catch (e) {\r\n      throw FirebaseAuthException(\r\n        code: 'signout-error',\r\n        message: 'Error during sign out: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<UserRole> getUserRole(String userId) async {\r\n    try {\r\n      DocumentSnapshot doc = await _firestore.collection('users').doc(userId).get();\r\n      if (!doc.exists) return UserRole.user;\r\n\r\n      String roleString = doc.get('role') as String? ?? 'user';\r\n      return UserRole.values.firstWhere(\r\n        (e) => e.toString().split('.').last.toLowerCase() == roleString.toLowerCase(),\r\n        orElse: () => UserRole.user,\r\n      );\r\n    } catch (e) {\r\n      throw FirebaseAuthException(\r\n        code: 'role-fetch-error',\r\n        message: 'Error getting user role: ${e.toString()}'\r\n      );\r\n    }\r\n  }\r\n}"
        }
    ]
}