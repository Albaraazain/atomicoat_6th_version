{
    "sourceFile": "lib/blocs/simulation/bloc/simulation_bloc.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1734062456976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1734062462346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,272 @@\n+// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n+import 'dart:async';\r\n+import 'dart:math';\r\n+import 'package:bloc/bloc.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n+import '../../component/bloc/component_bloc.dart';\r\n+import '../../component/bloc/component_event.dart';\r\n+import '../../alarm/bloc/alarm_bloc.dart';\r\n+import '../../alarm/bloc/alarm_event.dart';\r\n+import '../../safety/bloc/safety_bloc.dart';\r\n+import '../../safety/bloc/safety_event.dart';\r\n+import '../../utils/bloc_utils.dart';\r\n+import 'simulation_event.dart';\r\n+import 'simulation_state.dart';\r\n+\r\n+class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n+  final ComponentBloc _componentBloc;\r\n+  final AlarmBloc _alarmBloc;\r\n+  final SafetyBloc _safetyBloc;\r\n+  final Random _random = Random();\r\n+  Timer? _simulationTimer;\r\n+\r\n+  static const int SIMULATION_INTERVAL_MS = 500;\r\n+\r\n+  SimulationBloc({\r\n+    required ComponentBloc componentBloc,\r\n+    required AlarmBloc alarmBloc,\r\n+    required SafetyBloc safetyBloc,\r\n+  })  : _componentBloc = componentBloc,\r\n+        _alarmBloc = alarmBloc,\r\n+        _safetyBloc = safetyBloc,\r\n+        super(SimulationState.initial()) {\r\n+    on<StartSimulation>(_onStartSimulation);\r\n+    on<StopSimulation>(_onStopSimulation);\r\n+    on<SimulationTick>(_onSimulationTick);\r\n+    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n+    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n+    on<GenerateRandomError>(_onGenerateRandomError);\r\n+  }\r\n+\r\n+  Future<void> _onStartSimulation(\r\n+    StartSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status == SimulationStatus.running) return;\r\n+\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = Timer.periodic(\r\n+      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n+      (_) => add(SimulationTick()),\r\n+    );\r\n+\r\n+    emit(state.copyWith(\r\n+      status: SimulationStatus.running,\r\n+      tickCount: 0,\r\n+      lastComponentUpdates: {},\r\n+    ));\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation started',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onStopSimulation(\r\n+    StopSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = null;\r\n+\r\n+    emit(state.copyWith(\r\n+      status: SimulationStatus.idle,\r\n+    ));\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation stopped',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onSimulationTick(\r\n+    SimulationTick event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status != SimulationStatus.running) return;\r\n+\r\n+    try {\r\n+      // Update component values\r\n+      final updates = _generateComponentUpdates();\r\n+      if (updates.isNotEmpty) {\r\n+        add(UpdateComponentValues(updates));\r\n+      }\r\n+\r\n+      // Check safety conditions\r\n+      add(CheckSafetyConditions());\r\n+\r\n+      // Occasionally generate random errors\r\n+      if (_random.nextDouble() < 0.05) { // 5% chance per tick\r\n+        add(GenerateRandomError());\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        tickCount: state.tickCount + 1,\r\n+        lastUpdated: event.timestamp,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        status: SimulationStatus.error,\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onUpdateComponentValues(\r\n+    UpdateComponentValues event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    try {\r\n+      // Update primary components\r\n+      for (var entry in event.updates.entries) {\r\n+        _componentBloc.add(ComponentValueUpdated(\r\n+          entry.key,\r\n+          entry.value,\r\n+        ));\r\n+      }\r\n+\r\n+      // Handle dependencies\r\n+      final dependencyUpdates = _processDependencies(event.updates);\r\n+      if (dependencyUpdates.isNotEmpty) {\r\n+        for (var entry in dependencyUpdates.entries) {\r\n+          _componentBloc.add(ComponentValueUpdated(\r\n+            entry.key,\r\n+            entry.value,\r\n+          ));\r\n+        }\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        lastComponentUpdates: {\r\n+          ...state.lastComponentUpdates,\r\n+          for (var component in event.updates.keys)\r\n+            component: DateTime.now(),\r\n+        },\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onCheckSafetyConditions(\r\n+    CheckSafetyConditions event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    // Check chamber conditions\r\n+    _checkReactionChamber();\r\n+\r\n+    // Check other critical components\r\n+    _checkCriticalComponents();\r\n+  }\r\n+\r\n+  Future<void> _onGenerateRandomError(\r\n+    GenerateRandomError event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (_random.nextBool()) {\r\n+      // Component malfunction\r\n+      final componentName = _getRandomComponent();\r\n+      _componentBloc.add(ComponentErrorAdded(\r\n+        componentName,\r\n+        'Simulated malfunction detected',\r\n+      ));\r\n+\r\n+      _componentBloc.add(ComponentStatusUpdated(\r\n+        componentName,\r\n+        ComponentStatus.error,\r\n+      ));\r\n+    } else {\r\n+      // Safety error\r\n+      _safetyBloc.add(SafetyErrorDetected(\r\n+        SafetyError(\r\n+          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+          description: 'Simulated safety error detected',\r\n+          severity: _random.nextBool()\r\n+              ? SafetyErrorSeverity.warning\r\n+              : SafetyErrorSeverity.critical,\r\n+        ),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n+    final updates = <String, Map<String, double>>{};\r\n+\r\n+    // Example component updates - you might want to adjust these based on your needs\r\n+    updates['Reaction Chamber'] = {\r\n+      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n+      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n+    };\r\n+\r\n+    updates['MFC'] = {\r\n+      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n+    };\r\n+\r\n+    return updates;\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _processDependencies(\r\n+    Map<String, Map<String, double>> updates,\r\n+  ) {\r\n+    final dependencyUpdates = <String, Map<String, double>>{};\r\n+\r\n+    for (var entry in updates.entries) {\r\n+      final dependencies = state.dependencies[entry.key] ?? [];\r\n+      for (var dependent in dependencies) {\r\n+        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n+          dependencyUpdates[dependent] = {\r\n+            'flow_rate': _adjustDependentValue(\r\n+              entry.value['flow_rate']!,\r\n+              0.8,\r\n+              0.2,\r\n+            ),\r\n+          };\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    return dependencyUpdates;\r\n+  }\r\n+\r\n+  void _checkReactionChamber() {\r\n+    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n+    // Add specific chamber checks here\r\n+  }\r\n+\r\n+  void _checkCriticalComponents() {\r\n+    // Add checks for other critical components\r\n+  }\r\n+\r\n+  double _generateNewValue(String parameter, double setpoint, double fluctuation) {\r\n+    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n+    return setpoint + delta;\r\n+  }\r\n+\r\n+  double _adjustDependentValue(\r\n+    double baseValue,\r\n+    double factor,\r\n+    double fluctuation,\r\n+  ) {\r\n+    return baseValue * factor +\r\n+           _random.nextDouble() * fluctuation * 2 -\r\n+           fluctuation;\r\n+  }\r\n+\r\n+  String _getRandomComponent() {\r\n+    const components = [\r\n+      'Reaction Chamber',\r\n+      'MFC',\r\n+      'Vacuum Pump',\r\n+      'Pressure Control System',\r\n+    ];\r\n+    return components[_random.nextInt(components.length)];\r\n+  }\r\n+\r\n+  @override\r\n+  Future<void> close() {\r\n+    _simulationTimer?.cancel();\r\n+    return super.close();\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734070480379,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n       ));\r\n \r\n       _componentBloc.add(ComponentStatusUpdated(\r\n         componentName,\r\n-        ComponentStatus.error,\r\n+        ComponentStatus.error as ComponentStatus,\r\n       ));\r\n     } else {\r\n       // Safety error\r\n       _safetyBloc.add(SafetyErrorDetected(\r\n@@ -268,276 +268,5 @@\n   Future<void> close() {\r\n     _simulationTimer?.cancel();\r\n     return super.close();\r\n   }\r\n-}\n-// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n-import 'dart:async';\r\n-import 'dart:math';\r\n-import 'package:bloc/bloc.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n-import '../../component/bloc/component_bloc.dart';\r\n-import '../../component/bloc/component_event.dart';\r\n-import '../../alarm/bloc/alarm_bloc.dart';\r\n-import '../../alarm/bloc/alarm_event.dart';\r\n-import '../../safety/bloc/safety_bloc.dart';\r\n-import '../../safety/bloc/safety_event.dart';\r\n-import '../../utils/bloc_utils.dart';\r\n-import 'simulation_event.dart';\r\n-import 'simulation_state.dart';\r\n-\r\n-class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n-  final ComponentBloc _componentBloc;\r\n-  final AlarmBloc _alarmBloc;\r\n-  final SafetyBloc _safetyBloc;\r\n-  final Random _random = Random();\r\n-  Timer? _simulationTimer;\r\n-\r\n-  static const int SIMULATION_INTERVAL_MS = 500;\r\n-\r\n-  SimulationBloc({\r\n-    required ComponentBloc componentBloc,\r\n-    required AlarmBloc alarmBloc,\r\n-    required SafetyBloc safetyBloc,\r\n-  })  : _componentBloc = componentBloc,\r\n-        _alarmBloc = alarmBloc,\r\n-        _safetyBloc = safetyBloc,\r\n-        super(SimulationState.initial()) {\r\n-    on<StartSimulation>(_onStartSimulation);\r\n-    on<StopSimulation>(_onStopSimulation);\r\n-    on<SimulationTick>(_onSimulationTick);\r\n-    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n-    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n-    on<GenerateRandomError>(_onGenerateRandomError);\r\n-  }\r\n-\r\n-  Future<void> _onStartSimulation(\r\n-    StartSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status == SimulationStatus.running) return;\r\n-\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = Timer.periodic(\r\n-      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n-      (_) => add(SimulationTick()),\r\n-    );\r\n-\r\n-    emit(state.copyWith(\r\n-      status: SimulationStatus.running,\r\n-      tickCount: 0,\r\n-      lastComponentUpdates: {},\r\n-    ));\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation started',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onStopSimulation(\r\n-    StopSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = null;\r\n-\r\n-    emit(state.copyWith(\r\n-      status: SimulationStatus.idle,\r\n-    ));\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation stopped',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onSimulationTick(\r\n-    SimulationTick event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status != SimulationStatus.running) return;\r\n-\r\n-    try {\r\n-      // Update component values\r\n-      final updates = _generateComponentUpdates();\r\n-      if (updates.isNotEmpty) {\r\n-        add(UpdateComponentValues(updates));\r\n-      }\r\n-\r\n-      // Check safety conditions\r\n-      add(CheckSafetyConditions());\r\n-\r\n-      // Occasionally generate random errors\r\n-      if (_random.nextDouble() < 0.05) { // 5% chance per tick\r\n-        add(GenerateRandomError());\r\n-      }\r\n-\r\n-      emit(state.copyWith(\r\n-        tickCount: state.tickCount + 1,\r\n-        lastUpdated: event.timestamp,\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(\r\n-        status: SimulationStatus.error,\r\n-        error: BlocUtils.handleError(error),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-  Future<void> _onUpdateComponentValues(\r\n-    UpdateComponentValues event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    try {\r\n-      // Update primary components\r\n-      for (var entry in event.updates.entries) {\r\n-        _componentBloc.add(ComponentValueUpdated(\r\n-          entry.key,\r\n-          entry.value,\r\n-        ));\r\n-      }\r\n-\r\n-      // Handle dependencies\r\n-      final dependencyUpdates = _processDependencies(event.updates);\r\n-      if (dependencyUpdates.isNotEmpty) {\r\n-        for (var entry in dependencyUpdates.entries) {\r\n-          _componentBloc.add(ComponentValueUpdated(\r\n-            entry.key,\r\n-            entry.value,\r\n-          ));\r\n-        }\r\n-      }\r\n-\r\n-      emit(state.copyWith(\r\n-        lastComponentUpdates: {\r\n-          ...state.lastComponentUpdates,\r\n-          for (var component in event.updates.keys)\r\n-            component: DateTime.now(),\r\n-        },\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n-    }\r\n-  }\r\n-\r\n-  Future<void> _onCheckSafetyConditions(\r\n-    CheckSafetyConditions event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    // Check chamber conditions\r\n-    _checkReactionChamber();\r\n-\r\n-    // Check other critical components\r\n-    _checkCriticalComponents();\r\n-  }\r\n-\r\n-  Future<void> _onGenerateRandomError(\r\n-    GenerateRandomError event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (_random.nextBool()) {\r\n-      // Component malfunction\r\n-      final componentName = _getRandomComponent();\r\n-      _componentBloc.add(ComponentErrorAdded(\r\n-        componentName,\r\n-        'Simulated malfunction detected',\r\n-      ));\r\n-\r\n-      _componentBloc.add(ComponentStatusUpdated(\r\n-        componentName,\r\n-        ComponentStatus.error,\r\n-      ));\r\n-    } else {\r\n-      // Safety error\r\n-      _safetyBloc.add(SafetyErrorDetected(\r\n-        SafetyError(\r\n-          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n-          description: 'Simulated safety error detected',\r\n-          severity: _random.nextBool()\r\n-              ? SafetyErrorSeverity.warning\r\n-              : SafetyErrorSeverity.critical,\r\n-        ),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n-    final updates = <String, Map<String, double>>{};\r\n-\r\n-    // Example component updates - you might want to adjust these based on your needs\r\n-    updates['Reaction Chamber'] = {\r\n-      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n-      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n-    };\r\n-\r\n-    updates['MFC'] = {\r\n-      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n-    };\r\n-\r\n-    return updates;\r\n-  }\r\n-\r\n-  Map<String, Map<String, double>> _processDependencies(\r\n-    Map<String, Map<String, double>> updates,\r\n-  ) {\r\n-    final dependencyUpdates = <String, Map<String, double>>{};\r\n-\r\n-    for (var entry in updates.entries) {\r\n-      final dependencies = state.dependencies[entry.key] ?? [];\r\n-      for (var dependent in dependencies) {\r\n-        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n-          dependencyUpdates[dependent] = {\r\n-            'flow_rate': _adjustDependentValue(\r\n-              entry.value['flow_rate']!,\r\n-              0.8,\r\n-              0.2,\r\n-            ),\r\n-          };\r\n-        }\r\n-      }\r\n-    }\r\n-\r\n-    return dependencyUpdates;\r\n-  }\r\n-\r\n-  void _checkReactionChamber() {\r\n-    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n-    // Add specific chamber checks here\r\n-  }\r\n-\r\n-  void _checkCriticalComponents() {\r\n-    // Add checks for other critical components\r\n-  }\r\n-\r\n-  double _generateNewValue(String parameter, double setpoint, double fluctuation) {\r\n-    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n-    return setpoint + delta;\r\n-  }\r\n-\r\n-  double _adjustDependentValue(\r\n-    double baseValue,\r\n-    double factor,\r\n-    double fluctuation,\r\n-  ) {\r\n-    return baseValue * factor +\r\n-           _random.nextDouble() * fluctuation * 2 -\r\n-           fluctuation;\r\n-  }\r\n-\r\n-  String _getRandomComponent() {\r\n-    const components = [\r\n-      'Reaction Chamber',\r\n-      'MFC',\r\n-      'Vacuum Pump',\r\n-      'Pressure Control System',\r\n-    ];\r\n-    return components[_random.nextInt(components.length)];\r\n-  }\r\n-\r\n-  @override\r\n-  Future<void> close() {\r\n-    _simulationTimer?.cancel();\r\n-    return super.close();\r\n-  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1734070801031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n       ));\r\n \r\n       _componentBloc.add(ComponentStatusUpdated(\r\n         componentName,\r\n-        ComponentStatus.error as ComponentStatus,\r\n+        ComponentStatus.error, // Remove the cast\r\n       ));\r\n     } else {\r\n       // Safety error\r\n       _safetyBloc.add(SafetyErrorDetected(\r\n"
                },
                {
                    "date": 1734070855353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,21 +165,28 @@\n     GenerateRandomError event,\r\n     Emitter<SimulationState> emit,\r\n   ) async {\r\n     if (_random.nextBool()) {\r\n-      // Component malfunction\r\n       final componentName = _getRandomComponent();\r\n       _componentBloc.add(ComponentErrorAdded(\r\n         componentName,\r\n         'Simulated malfunction detected',\r\n       ));\r\n \r\n+      // Update ComponentStatus usage\r\n+      final component = SystemComponent(\r\n+        name: componentName,\r\n+        description: '',\r\n+        currentValues: {},\r\n+        setValues: {},\r\n+      );\r\n+      component.status = ComponentStatus.error;\r\n+\r\n       _componentBloc.add(ComponentStatusUpdated(\r\n         componentName,\r\n-        ComponentStatus.error, // Remove the cast\r\n+        component.status,\r\n       ));\r\n     } else {\r\n-      // Safety error\r\n       _safetyBloc.add(SafetyErrorDetected(\r\n         SafetyError(\r\n           id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n           description: 'Simulated safety error detected',\r\n"
                },
                {
                    "date": 1734072162112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,20 +18,22 @@\n class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n   final ComponentBloc _componentBloc;\r\n   final AlarmBloc _alarmBloc;\r\n   final SafetyBloc _safetyBloc;\r\n-  final Random _random = Random();\r\n+  final Random _random; // Make Random injectable\r\n   Timer? _simulationTimer;\r\n \r\n   static const int SIMULATION_INTERVAL_MS = 500;\r\n \r\n   SimulationBloc({\r\n     required ComponentBloc componentBloc,\r\n     required AlarmBloc alarmBloc,\r\n     required SafetyBloc safetyBloc,\r\n+    Random? random, // Add optional random parameter\r\n   })  : _componentBloc = componentBloc,\r\n         _alarmBloc = alarmBloc,\r\n         _safetyBloc = safetyBloc,\r\n+        _random = random ?? Random(), // Use provided random or create new one\r\n         super(SimulationState.initial()) {\r\n     on<StartSimulation>(_onStartSimulation);\r\n     on<StopSimulation>(_onStopSimulation);\r\n     on<SimulationTick>(_onSimulationTick);\r\n@@ -51,13 +53,14 @@\n       const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n       (_) => add(SimulationTick()),\r\n     );\r\n \r\n-    emit(state.copyWith(\r\n+    final newState = state.copyWith(\r\n       status: SimulationStatus.running,\r\n       tickCount: 0,\r\n       lastComponentUpdates: {},\r\n-    ));\r\n+    );\r\n+    emit(newState);\r\n \r\n     _alarmBloc.add(AddAlarm(\r\n       message: 'Simulation started',\r\n       severity: AlarmSeverity.info,\r\n@@ -67,21 +70,71 @@\n   Future<void> _onStopSimulation(\r\n     StopSimulation event,\r\n     Emitter<SimulationState> emit,\r\n   ) async {\r\n+    if (state.status != SimulationStatus.running) return; // Add this check\r\n+\r\n     _simulationTimer?.cancel();\r\n     _simulationTimer = null;\r\n \r\n-    emit(state.copyWith(\r\n+    final newState = state.copyWith(\r\n       status: SimulationStatus.idle,\r\n-    ));\r\n+    );\r\n+    emit(newState); // Ensure state is emitted before adding alarm\r\n \r\n     _alarmBloc.add(AddAlarm(\r\n       message: 'Simulation stopped',\r\n       severity: AlarmSeverity.info,\r\n     ));\r\n   }\r\n \r\n+  Future<void> _onGenerateRandomError(\r\n+    GenerateRandomError event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    final bool isComponentError = _random.nextBool();\r\n+\r\n+    if (isComponentError) {\r\n+      final componentName = _getRandomComponent();\r\n+      // Add component error\r\n+      _componentBloc.add(ComponentErrorAdded(\r\n+        componentName,\r\n+        'Simulated malfunction detected',\r\n+      ));\r\n+\r\n+      // Update status\r\n+      final component = SystemComponent(\r\n+        name: componentName,\r\n+        description: '',\r\n+        currentValues: {},\r\n+        setValues: {},\r\n+      );\r\n+      component.status = ComponentStatus.error;\r\n+\r\n+      // Add status update\r\n+      _componentBloc.add(ComponentStatusUpdated(\r\n+        componentName,\r\n+        component.status,\r\n+      ));\r\n+    } else {\r\n+      // Add safety error\r\n+      _safetyBloc.add(SafetyErrorDetected(\r\n+        SafetyError(\r\n+          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+          description: 'Simulated safety error detected',\r\n+          severity: _random.nextBool()\r\n+              ? SafetyErrorSeverity.warning\r\n+              : SafetyErrorSeverity.critical,\r\n+        ),\r\n+      ));\r\n+    }\r\n+\r\n+    // Emit a state to acknowledge the error generation\r\n+    emit(state.copyWith(\r\n+      lastUpdated: DateTime.now(),\r\n+    ));\r\n+  }\r\n+\r\n   Future<void> _onSimulationTick(\r\n     SimulationTick event,\r\n     Emitter<SimulationState> emit,\r\n   ) async {\r\n@@ -97,9 +150,10 @@\n       // Check safety conditions\r\n       add(CheckSafetyConditions());\r\n \r\n       // Occasionally generate random errors\r\n-      if (_random.nextDouble() < 0.05) { // 5% chance per tick\r\n+      if (_random.nextDouble() < 0.05) {\r\n+        // 5% chance per tick\r\n         add(GenerateRandomError());\r\n       }\r\n \r\n       emit(state.copyWith(\r\n@@ -140,10 +194,9 @@\n \r\n       emit(state.copyWith(\r\n         lastComponentUpdates: {\r\n           ...state.lastComponentUpdates,\r\n-          for (var component in event.updates.keys)\r\n-            component: DateTime.now(),\r\n+          for (var component in event.updates.keys) component: DateTime.now(),\r\n         },\r\n       ));\r\n     } catch (error) {\r\n       emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n@@ -160,45 +213,8 @@\n     // Check other critical components\r\n     _checkCriticalComponents();\r\n   }\r\n \r\n-  Future<void> _onGenerateRandomError(\r\n-    GenerateRandomError event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (_random.nextBool()) {\r\n-      final componentName = _getRandomComponent();\r\n-      _componentBloc.add(ComponentErrorAdded(\r\n-        componentName,\r\n-        'Simulated malfunction detected',\r\n-      ));\r\n-\r\n-      // Update ComponentStatus usage\r\n-      final component = SystemComponent(\r\n-        name: componentName,\r\n-        description: '',\r\n-        currentValues: {},\r\n-        setValues: {},\r\n-      );\r\n-      component.status = ComponentStatus.error;\r\n-\r\n-      _componentBloc.add(ComponentStatusUpdated(\r\n-        componentName,\r\n-        component.status,\r\n-      ));\r\n-    } else {\r\n-      _safetyBloc.add(SafetyErrorDetected(\r\n-        SafetyError(\r\n-          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n-          description: 'Simulated safety error detected',\r\n-          severity: _random.nextBool()\r\n-              ? SafetyErrorSeverity.warning\r\n-              : SafetyErrorSeverity.critical,\r\n-        ),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n   Map<String, Map<String, double>> _generateComponentUpdates() {\r\n     final updates = <String, Map<String, double>>{};\r\n \r\n     // Example component updates - you might want to adjust these based on your needs\r\n@@ -245,9 +261,10 @@\n   void _checkCriticalComponents() {\r\n     // Add checks for other critical components\r\n   }\r\n \r\n-  double _generateNewValue(String parameter, double setpoint, double fluctuation) {\r\n+  double _generateNewValue(\r\n+      String parameter, double setpoint, double fluctuation) {\r\n     double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n     return setpoint + delta;\r\n   }\r\n \r\n@@ -256,10 +273,10 @@\n     double factor,\r\n     double fluctuation,\r\n   ) {\r\n     return baseValue * factor +\r\n-           _random.nextDouble() * fluctuation * 2 -\r\n-           fluctuation;\r\n+        _random.nextDouble() * fluctuation * 2 -\r\n+        fluctuation;\r\n   }\r\n \r\n   String _getRandomComponent() {\r\n     const components = [\r\n@@ -275,5 +292,5 @@\n   Future<void> close() {\r\n     _simulationTimer?.cancel();\r\n     return super.close();\r\n   }\r\n-}\n\\ No newline at end of file\n+}\r\n"
                },
                {
                    "date": 1734072305553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,13 +90,16 @@\n   Future<void> _onGenerateRandomError(\r\n     GenerateRandomError event,\r\n     Emitter<SimulationState> emit,\r\n   ) async {\r\n-    final bool isComponentError = _random.nextBool();\r\n+    final isComponentError =\r\n+        true; // Force component error for predictable testing\r\n \r\n     if (isComponentError) {\r\n-      final componentName = _getRandomComponent();\r\n-      // Add component error\r\n+      final componentName =\r\n+          'Reaction Chamber'; // Use fixed component for testing\r\n+\r\n+      // Add error\r\n       _componentBloc.add(ComponentErrorAdded(\r\n         componentName,\r\n         'Simulated malfunction detected',\r\n       ));\r\n@@ -109,30 +112,26 @@\n         setValues: {},\r\n       );\r\n       component.status = ComponentStatus.error;\r\n \r\n-      // Add status update\r\n       _componentBloc.add(ComponentStatusUpdated(\r\n         componentName,\r\n         component.status,\r\n       ));\r\n+\r\n+      // Emit state to acknowledge error\r\n+      emit(state.copyWith(\r\n+        lastUpdated: DateTime.now(),\r\n+      ));\r\n     } else {\r\n-      // Add safety error\r\n       _safetyBloc.add(SafetyErrorDetected(\r\n         SafetyError(\r\n           id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n           description: 'Simulated safety error detected',\r\n-          severity: _random.nextBool()\r\n-              ? SafetyErrorSeverity.warning\r\n-              : SafetyErrorSeverity.critical,\r\n+          severity: SafetyErrorSeverity.critical,\r\n         ),\r\n       ));\r\n     }\r\n-\r\n-    // Emit a state to acknowledge the error generation\r\n-    emit(state.copyWith(\r\n-      lastUpdated: DateTime.now(),\r\n-    ));\r\n   }\r\n \r\n   Future<void> _onSimulationTick(\r\n     SimulationTick event,\r\n"
                },
                {
                    "date": 1734072351143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,296 @@\n+// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n+import 'dart:async';\r\n+import 'dart:math';\r\n+import 'package:bloc/bloc.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n+import '../../component/bloc/component_bloc.dart';\r\n+import '../../component/bloc/component_event.dart';\r\n+import '../../alarm/bloc/alarm_bloc.dart';\r\n+import '../../alarm/bloc/alarm_event.dart';\r\n+import '../../safety/bloc/safety_bloc.dart';\r\n+import '../../safety/bloc/safety_event.dart';\r\n+import '../../utils/bloc_utils.dart';\r\n+import 'simulation_event.dart';\r\n+import 'simulation_state.dart';\r\n+\r\n+class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n+  final ComponentBloc _componentBloc;\r\n+  final AlarmBloc _alarmBloc;\r\n+  final SafetyBloc _safetyBloc;\r\n+  final Random _random; // Make Random injectable\r\n+  Timer? _simulationTimer;\r\n+\r\n+  static const int SIMULATION_INTERVAL_MS = 500;\r\n+\r\n+  SimulationBloc({\r\n+    required ComponentBloc componentBloc,\r\n+    required AlarmBloc alarmBloc,\r\n+    required SafetyBloc safetyBloc,\r\n+    Random? random, // Add optional random parameter\r\n+  })  : _componentBloc = componentBloc,\r\n+        _alarmBloc = alarmBloc,\r\n+        _safetyBloc = safetyBloc,\r\n+        _random = random ?? Random(), // Use provided random or create new one\r\n+        super(SimulationState.initial()) {\r\n+    on<StartSimulation>(_onStartSimulation);\r\n+    on<StopSimulation>(_onStopSimulation);\r\n+    on<SimulationTick>(_onSimulationTick);\r\n+    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n+    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n+    on<GenerateRandomError>(_onGenerateRandomError);\r\n+  }\r\n+\r\n+  Future<void> _onStartSimulation(\r\n+    StartSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status == SimulationStatus.running) return;\r\n+\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = Timer.periodic(\r\n+      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n+      (_) => add(SimulationTick()),\r\n+    );\r\n+\r\n+    final newState = state.copyWith(\r\n+      status: SimulationStatus.running,\r\n+      tickCount: 0,\r\n+      lastComponentUpdates: {},\r\n+    );\r\n+    emit(newState);\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation started',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onStopSimulation(\r\n+    StopSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status != SimulationStatus.running) return; // Add this check\r\n+\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = null;\r\n+\r\n+    final newState = state.copyWith(\r\n+      status: SimulationStatus.idle,\r\n+    );\r\n+    emit(newState); // Ensure state is emitted before adding alarm\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation stopped',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onGenerateRandomError(\r\n+    GenerateRandomError event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    final isComponentError =\r\n+        true; // Force component error for predictable testing\r\n+\r\n+    if (isComponentError) {\r\n+      final componentName =\r\n+          'Reaction Chamber'; // Use fixed component for testing\r\n+\r\n+      // Add error\r\n+      _componentBloc.add(ComponentErrorAdded(\r\n+        componentName,\r\n+        'Simulated malfunction detected',\r\n+      ));\r\n+\r\n+      // Update status\r\n+      final component = SystemComponent(\r\n+        name: componentName,\r\n+        description: '',\r\n+        currentValues: {},\r\n+        setValues: {},\r\n+      );\r\n+      component.status = ComponentStatus.error;\r\n+\r\n+      _componentBloc.add(ComponentStatusUpdated(\r\n+        componentName,\r\n+        component.status,\r\n+      ));\r\n+\r\n+      // Emit state to acknowledge error\r\n+      emit(state.copyWith(\r\n+        lastUpdated: DateTime.now(),\r\n+      ));\r\n+    } else {\r\n+      _safetyBloc.add(SafetyErrorDetected(\r\n+        SafetyError(\r\n+          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+          description: 'Simulated safety error detected',\r\n+          severity: SafetyErrorSeverity.critical,\r\n+        ),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+\r\n+  Future<void> _onSimulationTick(\r\n+    SimulationTick event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status != SimulationStatus.running) return;\r\n+\r\n+    try {\r\n+      // Update component values\r\n+      final updates = _generateComponentUpdates();\r\n+      if (updates.isNotEmpty) {\r\n+        add(UpdateComponentValues(updates));\r\n+      }\r\n+\r\n+      // Check safety conditions\r\n+      add(CheckSafetyConditions());\r\n+\r\n+      // Occasionally generate random errors\r\n+      if (_random.nextDouble() < 0.05) {\r\n+        // 5% chance per tick\r\n+        add(GenerateRandomError());\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        tickCount: state.tickCount + 1,\r\n+        lastUpdated: event.timestamp,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        status: SimulationStatus.error,\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onUpdateComponentValues(\r\n+    UpdateComponentValues event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    try {\r\n+      // Update primary components\r\n+      for (var entry in event.updates.entries) {\r\n+        _componentBloc.add(ComponentValueUpdated(\r\n+          entry.key,\r\n+          entry.value,\r\n+        ));\r\n+      }\r\n+\r\n+      // Handle dependencies\r\n+      final dependencyUpdates = _processDependencies(event.updates);\r\n+      if (dependencyUpdates.isNotEmpty) {\r\n+        for (var entry in dependencyUpdates.entries) {\r\n+          _componentBloc.add(ComponentValueUpdated(\r\n+            entry.key,\r\n+            entry.value,\r\n+          ));\r\n+        }\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        lastComponentUpdates: {\r\n+          ...state.lastComponentUpdates,\r\n+          for (var component in event.updates.keys) component: DateTime.now(),\r\n+        },\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onCheckSafetyConditions(\r\n+    CheckSafetyConditions event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    // Check chamber conditions\r\n+    _checkReactionChamber();\r\n+\r\n+    // Check other critical components\r\n+    _checkCriticalComponents();\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n+    final updates = <String, Map<String, double>>{};\r\n+\r\n+    // Example component updates - you might want to adjust these based on your needs\r\n+    updates['Reaction Chamber'] = {\r\n+      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n+      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n+    };\r\n+\r\n+    updates['MFC'] = {\r\n+      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n+    };\r\n+\r\n+    return updates;\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _processDependencies(\r\n+    Map<String, Map<String, double>> updates,\r\n+  ) {\r\n+    final dependencyUpdates = <String, Map<String, double>>{};\r\n+\r\n+    for (var entry in updates.entries) {\r\n+      final dependencies = state.dependencies[entry.key] ?? [];\r\n+      for (var dependent in dependencies) {\r\n+        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n+          dependencyUpdates[dependent] = {\r\n+            'flow_rate': _adjustDependentValue(\r\n+              entry.value['flow_rate']!,\r\n+              0.8,\r\n+              0.2,\r\n+            ),\r\n+          };\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    return dependencyUpdates;\r\n+  }\r\n+\r\n+  void _checkReactionChamber() {\r\n+    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n+    // Add specific chamber checks here\r\n+  }\r\n+\r\n+  void _checkCriticalComponents() {\r\n+    // Add checks for other critical components\r\n+  }\r\n+\r\n+  double _generateNewValue(\r\n+      String parameter, double setpoint, double fluctuation) {\r\n+    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n+    return setpoint + delta;\r\n+  }\r\n+\r\n+  double _adjustDependentValue(\r\n+    double baseValue,\r\n+    double factor,\r\n+    double fluctuation,\r\n+  ) {\r\n+    return baseValue * factor +\r\n+        _random.nextDouble() * fluctuation * 2 -\r\n+        fluctuation;\r\n+  }\r\n+\r\n+  String _getRandomComponent() {\r\n+    const components = [\r\n+      'Reaction Chamber',\r\n+      'MFC',\r\n+      'Vacuum Pump',\r\n+      'Pressure Control System',\r\n+    ];\r\n+    return components[_random.nextInt(components.length)];\r\n+  }\r\n+\r\n+  @override\r\n+  Future<void> close() {\r\n+    _simulationTimer?.cancel();\r\n+    return super.close();\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1734072368728,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,296 @@\n+// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n+import 'dart:async';\r\n+import 'dart:math';\r\n+import 'package:bloc/bloc.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n+import '../../component/bloc/component_bloc.dart';\r\n+import '../../component/bloc/component_event.dart';\r\n+import '../../alarm/bloc/alarm_bloc.dart';\r\n+import '../../alarm/bloc/alarm_event.dart';\r\n+import '../../safety/bloc/safety_bloc.dart';\r\n+import '../../safety/bloc/safety_event.dart';\r\n+import '../../utils/bloc_utils.dart';\r\n+import 'simulation_event.dart';\r\n+import 'simulation_state.dart';\r\n+\r\n+class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n+  final ComponentBloc _componentBloc;\r\n+  final AlarmBloc _alarmBloc;\r\n+  final SafetyBloc _safetyBloc;\r\n+  final Random _random; // Make Random injectable\r\n+  Timer? _simulationTimer;\r\n+\r\n+  static const int SIMULATION_INTERVAL_MS = 500;\r\n+\r\n+  SimulationBloc({\r\n+    required ComponentBloc componentBloc,\r\n+    required AlarmBloc alarmBloc,\r\n+    required SafetyBloc safetyBloc,\r\n+    Random? random, // Add optional random parameter\r\n+  })  : _componentBloc = componentBloc,\r\n+        _alarmBloc = alarmBloc,\r\n+        _safetyBloc = safetyBloc,\r\n+        _random = random ?? Random(), // Use provided random or create new one\r\n+        super(SimulationState.initial()) {\r\n+    on<StartSimulation>(_onStartSimulation);\r\n+    on<StopSimulation>(_onStopSimulation);\r\n+    on<SimulationTick>(_onSimulationTick);\r\n+    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n+    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n+    on<GenerateRandomError>(_onGenerateRandomError);\r\n+  }\r\n+\r\n+  Future<void> _onStartSimulation(\r\n+    StartSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status == SimulationStatus.running) return;\r\n+\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = Timer.periodic(\r\n+      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n+      (_) => add(SimulationTick()),\r\n+    );\r\n+\r\n+    final newState = state.copyWith(\r\n+      status: SimulationStatus.running,\r\n+      tickCount: 0,\r\n+      lastComponentUpdates: {},\r\n+    );\r\n+    emit(newState);\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation started',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onStopSimulation(\r\n+    StopSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status != SimulationStatus.running) return; // Add this check\r\n+\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = null;\r\n+\r\n+    final newState = state.copyWith(\r\n+      status: SimulationStatus.idle,\r\n+    );\r\n+    emit(newState); // Ensure state is emitted before adding alarm\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation stopped',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onGenerateRandomError(\r\n+    GenerateRandomError event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    final isComponentError =\r\n+        _random.nextBool(); // Randomly choose between component and safety error\r\n+\r\n+    if (isComponentError) {\r\n+      final componentName =\r\n+          _getRandomComponent(); // Use random component from available list\r\n+\r\n+      // Add error\r\n+      _componentBloc.add(ComponentErrorAdded(\r\n+        componentName,\r\n+        'Simulated malfunction detected',\r\n+      ));\r\n+\r\n+      // Update status\r\n+      final component = SystemComponent(\r\n+        name: componentName,\r\n+        description: '',\r\n+        currentValues: {},\r\n+        setValues: {},\r\n+      );\r\n+      component.status = ComponentStatus.error;\r\n+\r\n+      _componentBloc.add(ComponentStatusUpdated(\r\n+        componentName,\r\n+        component.status,\r\n+      ));\r\n+\r\n+      // Emit state to acknowledge error\r\n+      emit(state.copyWith(\r\n+        lastUpdated: DateTime.now(),\r\n+      ));\r\n+    } else {\r\n+      _safetyBloc.add(SafetyErrorDetected(\r\n+        SafetyError(\r\n+          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+          description: 'Simulated safety error detected',\r\n+          severity: SafetyErrorSeverity.critical,\r\n+        ),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+\r\n+  Future<void> _onSimulationTick(\r\n+    SimulationTick event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status != SimulationStatus.running) return;\r\n+\r\n+    try {\r\n+      // Update component values\r\n+      final updates = _generateComponentUpdates();\r\n+      if (updates.isNotEmpty) {\r\n+        add(UpdateComponentValues(updates));\r\n+      }\r\n+\r\n+      // Check safety conditions\r\n+      add(CheckSafetyConditions());\r\n+\r\n+      // Occasionally generate random errors\r\n+      if (_random.nextDouble() < 0.05) {\r\n+        // 5% chance per tick\r\n+        add(GenerateRandomError());\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        tickCount: state.tickCount + 1,\r\n+        lastUpdated: event.timestamp,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        status: SimulationStatus.error,\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onUpdateComponentValues(\r\n+    UpdateComponentValues event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    try {\r\n+      // Update primary components\r\n+      for (var entry in event.updates.entries) {\r\n+        _componentBloc.add(ComponentValueUpdated(\r\n+          entry.key,\r\n+          entry.value,\r\n+        ));\r\n+      }\r\n+\r\n+      // Handle dependencies\r\n+      final dependencyUpdates = _processDependencies(event.updates);\r\n+      if (dependencyUpdates.isNotEmpty) {\r\n+        for (var entry in dependencyUpdates.entries) {\r\n+          _componentBloc.add(ComponentValueUpdated(\r\n+            entry.key,\r\n+            entry.value,\r\n+          ));\r\n+        }\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        lastComponentUpdates: {\r\n+          ...state.lastComponentUpdates,\r\n+          for (var component in event.updates.keys) component: DateTime.now(),\r\n+        },\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onCheckSafetyConditions(\r\n+    CheckSafetyConditions event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    // Check chamber conditions\r\n+    _checkReactionChamber();\r\n+\r\n+    // Check other critical components\r\n+    _checkCriticalComponents();\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n+    final updates = <String, Map<String, double>>{};\r\n+\r\n+    // Example component updates - you might want to adjust these based on your needs\r\n+    updates['Reaction Chamber'] = {\r\n+      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n+      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n+    };\r\n+\r\n+    updates['MFC'] = {\r\n+      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n+    };\r\n+\r\n+    return updates;\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _processDependencies(\r\n+    Map<String, Map<String, double>> updates,\r\n+  ) {\r\n+    final dependencyUpdates = <String, Map<String, double>>{};\r\n+\r\n+    for (var entry in updates.entries) {\r\n+      final dependencies = state.dependencies[entry.key] ?? [];\r\n+      for (var dependent in dependencies) {\r\n+        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n+          dependencyUpdates[dependent] = {\r\n+            'flow_rate': _adjustDependentValue(\r\n+              entry.value['flow_rate']!,\r\n+              0.8,\r\n+              0.2,\r\n+            ),\r\n+          };\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    return dependencyUpdates;\r\n+  }\r\n+\r\n+  void _checkReactionChamber() {\r\n+    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n+    // Add specific chamber checks here\r\n+  }\r\n+\r\n+  void _checkCriticalComponents() {\r\n+    // Add checks for other critical components\r\n+  }\r\n+\r\n+  double _generateNewValue(\r\n+      String parameter, double setpoint, double fluctuation) {\r\n+    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n+    return setpoint + delta;\r\n+  }\r\n+\r\n+  double _adjustDependentValue(\r\n+    double baseValue,\r\n+    double factor,\r\n+    double fluctuation,\r\n+  ) {\r\n+    return baseValue * factor +\r\n+        _random.nextDouble() * fluctuation * 2 -\r\n+        fluctuation;\r\n+  }\r\n+\r\n+  String _getRandomComponent() {\r\n+    const components = [\r\n+      'Reaction Chamber',\r\n+      'MFC',\r\n+      'Vacuum Pump',\r\n+      'Pressure Control System',\r\n+    ];\r\n+    return components[_random.nextInt(components.length)];\r\n+  }\r\n+\r\n+  @override\r\n+  Future<void> close() {\r\n+    _simulationTimer?.cancel();\r\n+    return super.close();\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1734072384365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,294 @@\n+// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n+import 'dart:async';\r\n+import 'dart:math';\r\n+import 'package:bloc/bloc.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n+import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n+import '../../component/bloc/component_bloc.dart';\r\n+import '../../component/bloc/component_event.dart';\r\n+import '../../alarm/bloc/alarm_bloc.dart';\r\n+import '../../alarm/bloc/alarm_event.dart';\r\n+import '../../safety/bloc/safety_bloc.dart';\r\n+import '../../safety/bloc/safety_event.dart';\r\n+import '../../utils/bloc_utils.dart';\r\n+import 'simulation_event.dart';\r\n+import 'simulation_state.dart';\r\n+\r\n+class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n+  final ComponentBloc _componentBloc;\r\n+  final AlarmBloc _alarmBloc;\r\n+  final SafetyBloc _safetyBloc;\r\n+  final Random _random; // Make Random injectable\r\n+  Timer? _simulationTimer;\r\n+\r\n+  static const int SIMULATION_INTERVAL_MS = 500;\r\n+\r\n+  SimulationBloc({\r\n+    required ComponentBloc componentBloc,\r\n+    required AlarmBloc alarmBloc,\r\n+    required SafetyBloc safetyBloc,\r\n+    Random? random, // Add optional random parameter\r\n+  })  : _componentBloc = componentBloc,\r\n+        _alarmBloc = alarmBloc,\r\n+        _safetyBloc = safetyBloc,\r\n+        _random = random ?? Random(), // Use provided random or create new one\r\n+        super(SimulationState.initial()) {\r\n+    on<StartSimulation>(_onStartSimulation);\r\n+    on<StopSimulation>(_onStopSimulation);\r\n+    on<SimulationTick>(_onSimulationTick);\r\n+    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n+    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n+    on<GenerateRandomError>(_onGenerateRandomError);\r\n+  }\r\n+\r\n+  Future<void> _onStartSimulation(\r\n+    StartSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status == SimulationStatus.running) return;\r\n+\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = Timer.periodic(\r\n+      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n+      (_) => add(SimulationTick()),\r\n+    );\r\n+\r\n+    final newState = state.copyWith(\r\n+      status: SimulationStatus.running,\r\n+      tickCount: 0,\r\n+      lastComponentUpdates: {},\r\n+    );\r\n+    emit(newState);\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation started',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onStopSimulation(\r\n+    StopSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = null;\r\n+\r\n+    // Important: emit state before adding alarm\r\n+    emit(state.copyWith(\r\n+      status: SimulationStatus.idle,\r\n+      lastUpdated: DateTime.now(),\r\n+    ));\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation stopped',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onGenerateRandomError(\r\n+    GenerateRandomError event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    final isComponentError = _random\r\n+        .nextBool(); // Randomly choose between component and safety error\r\n+\r\n+    if (isComponentError) {\r\n+      final componentName =\r\n+          _getRandomComponent(); // Use random component from available list\r\n+\r\n+      // Add error\r\n+      _componentBloc.add(ComponentErrorAdded(\r\n+        componentName,\r\n+        'Simulated malfunction detected',\r\n+      ));\r\n+\r\n+      // Update status\r\n+      final component = SystemComponent(\r\n+        name: componentName,\r\n+        description: '',\r\n+        currentValues: {},\r\n+        setValues: {},\r\n+      );\r\n+      component.status = ComponentStatus.error;\r\n+\r\n+      _componentBloc.add(ComponentStatusUpdated(\r\n+        componentName,\r\n+        component.status,\r\n+      ));\r\n+\r\n+      // Emit state to acknowledge error\r\n+      emit(state.copyWith(\r\n+        lastUpdated: DateTime.now(),\r\n+      ));\r\n+    } else {\r\n+      _safetyBloc.add(SafetyErrorDetected(\r\n+        SafetyError(\r\n+          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+          description: 'Simulated safety error detected',\r\n+          severity: SafetyErrorSeverity.critical,\r\n+        ),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onSimulationTick(\r\n+    SimulationTick event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status != SimulationStatus.running) return;\r\n+\r\n+    try {\r\n+      // Update component values\r\n+      final updates = _generateComponentUpdates();\r\n+      if (updates.isNotEmpty) {\r\n+        add(UpdateComponentValues(updates));\r\n+      }\r\n+\r\n+      // Check safety conditions\r\n+      add(CheckSafetyConditions());\r\n+\r\n+      // Occasionally generate random errors\r\n+      if (_random.nextDouble() < 0.05) {\r\n+        // 5% chance per tick\r\n+        add(GenerateRandomError());\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        tickCount: state.tickCount + 1,\r\n+        lastUpdated: event.timestamp,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        status: SimulationStatus.error,\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onUpdateComponentValues(\r\n+    UpdateComponentValues event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    try {\r\n+      // Update primary components\r\n+      for (var entry in event.updates.entries) {\r\n+        _componentBloc.add(ComponentValueUpdated(\r\n+          entry.key,\r\n+          entry.value,\r\n+        ));\r\n+      }\r\n+\r\n+      // Handle dependencies\r\n+      final dependencyUpdates = _processDependencies(event.updates);\r\n+      if (dependencyUpdates.isNotEmpty) {\r\n+        for (var entry in dependencyUpdates.entries) {\r\n+          _componentBloc.add(ComponentValueUpdated(\r\n+            entry.key,\r\n+            entry.value,\r\n+          ));\r\n+        }\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        lastComponentUpdates: {\r\n+          ...state.lastComponentUpdates,\r\n+          for (var component in event.updates.keys) component: DateTime.now(),\r\n+        },\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onCheckSafetyConditions(\r\n+    CheckSafetyConditions event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    // Check chamber conditions\r\n+    _checkReactionChamber();\r\n+\r\n+    // Check other critical components\r\n+    _checkCriticalComponents();\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n+    final updates = <String, Map<String, double>>{};\r\n+\r\n+    // Example component updates - you might want to adjust these based on your needs\r\n+    updates['Reaction Chamber'] = {\r\n+      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n+      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n+    };\r\n+\r\n+    updates['MFC'] = {\r\n+      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n+    };\r\n+\r\n+    return updates;\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _processDependencies(\r\n+    Map<String, Map<String, double>> updates,\r\n+  ) {\r\n+    final dependencyUpdates = <String, Map<String, double>>{};\r\n+\r\n+    for (var entry in updates.entries) {\r\n+      final dependencies = state.dependencies[entry.key] ?? [];\r\n+      for (var dependent in dependencies) {\r\n+        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n+          dependencyUpdates[dependent] = {\r\n+            'flow_rate': _adjustDependentValue(\r\n+              entry.value['flow_rate']!,\r\n+              0.8,\r\n+              0.2,\r\n+            ),\r\n+          };\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    return dependencyUpdates;\r\n+  }\r\n+\r\n+  void _checkReactionChamber() {\r\n+    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n+    // Add specific chamber checks here\r\n+  }\r\n+\r\n+  void _checkCriticalComponents() {\r\n+    // Add checks for other critical components\r\n+  }\r\n+\r\n+  double _generateNewValue(\r\n+      String parameter, double setpoint, double fluctuation) {\r\n+    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n+    return setpoint + delta;\r\n+  }\r\n+\r\n+  double _adjustDependentValue(\r\n+    double baseValue,\r\n+    double factor,\r\n+    double fluctuation,\r\n+  ) {\r\n+    return baseValue * factor +\r\n+        _random.nextDouble() * fluctuation * 2 -\r\n+        fluctuation;\r\n+  }\r\n+\r\n+  String _getRandomComponent() {\r\n+    const components = [\r\n+      'Reaction Chamber',\r\n+      'MFC',\r\n+      'Vacuum Pump',\r\n+      'Pressure Control System',\r\n+    ];\r\n+    return components[_random.nextInt(components.length)];\r\n+  }\r\n+\r\n+  @override\r\n+  Future<void> close() {\r\n+    _simulationTimer?.cancel();\r\n+    return super.close();\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1734072457660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,16 +70,17 @@\n   Future<void> _onStopSimulation(\r\n     StopSimulation event,\r\n     Emitter<SimulationState> emit,\r\n   ) async {\r\n+    if (state.status != SimulationStatus.running) return; // Add this check\r\n+\r\n     _simulationTimer?.cancel();\r\n     _simulationTimer = null;\r\n \r\n-    // Important: emit state before adding alarm\r\n-    emit(state.copyWith(\r\n+    final newState = state.copyWith(\r\n       status: SimulationStatus.idle,\r\n-      lastUpdated: DateTime.now(),\r\n-    ));\r\n+    );\r\n+    emit(newState); // Ensure state is emitted before adding alarm\r\n \r\n     _alarmBloc.add(AddAlarm(\r\n       message: 'Simulation stopped',\r\n       severity: AlarmSeverity.info,\r\n@@ -89,22 +90,22 @@\n   Future<void> _onGenerateRandomError(\r\n     GenerateRandomError event,\r\n     Emitter<SimulationState> emit,\r\n   ) async {\r\n-    final isComponentError = _random\r\n-        .nextBool(); // Randomly choose between component and safety error\r\n+    final isComponentError = _random.nextBool();\r\n \r\n+    // Always emit a state to acknowledge the event\r\n+    emit(state.copyWith(\r\n+      lastUpdated: DateTime.now(),\r\n+    ));\r\n+\r\n     if (isComponentError) {\r\n-      final componentName =\r\n-          _getRandomComponent(); // Use random component from available list\r\n-\r\n-      // Add error\r\n+      final componentName = _getRandomComponent();\r\n       _componentBloc.add(ComponentErrorAdded(\r\n         componentName,\r\n         'Simulated malfunction detected',\r\n       ));\r\n \r\n-      // Update status\r\n       final component = SystemComponent(\r\n         name: componentName,\r\n         description: '',\r\n         currentValues: {},\r\n@@ -115,19 +116,16 @@\n       _componentBloc.add(ComponentStatusUpdated(\r\n         componentName,\r\n         component.status,\r\n       ));\r\n-\r\n-      // Emit state to acknowledge error\r\n-      emit(state.copyWith(\r\n-        lastUpdated: DateTime.now(),\r\n-      ));\r\n     } else {\r\n       _safetyBloc.add(SafetyErrorDetected(\r\n         SafetyError(\r\n           id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n           description: 'Simulated safety error detected',\r\n-          severity: SafetyErrorSeverity.critical,\r\n+          severity: _random.nextBool()\r\n+              ? SafetyErrorSeverity.warning\r\n+              : SafetyErrorSeverity.critical,\r\n         ),\r\n       ));\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1734072470397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,17 +70,16 @@\n   Future<void> _onStopSimulation(\r\n     StopSimulation event,\r\n     Emitter<SimulationState> emit,\r\n   ) async {\r\n-    if (state.status != SimulationStatus.running) return; // Add this check\r\n-\r\n     _simulationTimer?.cancel();\r\n     _simulationTimer = null;\r\n \r\n-    final newState = state.copyWith(\r\n+    // Important: emit state before adding alarm\r\n+    emit(state.copyWith(\r\n       status: SimulationStatus.idle,\r\n-    );\r\n-    emit(newState); // Ensure state is emitted before adding alarm\r\n+      lastUpdated: DateTime.now(),\r\n+    ));\r\n \r\n     _alarmBloc.add(AddAlarm(\r\n       message: 'Simulation stopped',\r\n       severity: AlarmSeverity.info,\r\n"
                },
                {
                    "date": 1734072816431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,18 +211,25 @@\n \r\n   Map<String, Map<String, double>> _generateComponentUpdates() {\r\n     final updates = <String, Map<String, double>>{};\r\n \r\n-    // Example component updates - you might want to adjust these based on your needs\r\n-    updates['Reaction Chamber'] = {\r\n-      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n-      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n-    };\r\n+    for (var entry in state.componentBehaviors.entries) {\r\n+      final componentName = entry.key;\r\n+      final behavior = entry.value;\r\n \r\n-    updates['MFC'] = {\r\n-      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n-    };\r\n+      // Get current values from component\r\n+      final component = _getComponentState(componentName);\r\n+      if (component != null && component.isActivated) {\r\n+        final newValues = behavior.generateValues(component.currentValues);\r\n \r\n+        // Only include if values changed and are valid\r\n+        if (_hasValuesChanged(component.currentValues, newValues) &&\r\n+            behavior.validateValues(newValues)) {\r\n+          updates[componentName] = newValues;\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n     return updates;\r\n   }\r\n \r\n   Map<String, Map<String, double>> _processDependencies(\r\n"
                },
                {
                    "date": 1734072868609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -231,927 +231,107 @@\n \r\n     return updates;\r\n   }\r\n \r\n-  Map<String, Map<String, double>> _processDependencies(\r\n-    Map<String, Map<String, double>> updates,\r\n-  ) {\r\n-    final dependencyUpdates = <String, Map<String, double>>{};\r\n-\r\n-    for (var entry in updates.entries) {\r\n-      final dependencies = state.dependencies[entry.key] ?? [];\r\n-      for (var dependent in dependencies) {\r\n-        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n-          dependencyUpdates[dependent] = {\r\n-            'flow_rate': _adjustDependentValue(\r\n-              entry.value['flow_rate']!,\r\n-              0.8,\r\n-              0.2,\r\n-            ),\r\n-          };\r\n-        }\r\n-      }\r\n+  SystemComponent? _getComponentState(String componentName) {\r\n+    try {\r\n+      _componentBloc.add(ComponentInitialized(componentName));\r\n+      return _componentBloc.state.component;\r\n+    } catch (e) {\r\n+      return null;\r\n     }\r\n-\r\n-    return dependencyUpdates;\r\n   }\r\n \r\n-  void _checkReactionChamber() {\r\n-    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n-    // Add specific chamber checks here\r\n-  }\r\n-\r\n-  void _checkCriticalComponents() {\r\n-    // Add checks for other critical components\r\n-  }\r\n-\r\n-  double _generateNewValue(\r\n-      String parameter, double setpoint, double fluctuation) {\r\n-    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n-    return setpoint + delta;\r\n-  }\r\n-\r\n-  double _adjustDependentValue(\r\n-    double baseValue,\r\n-    double factor,\r\n-    double fluctuation,\r\n+  bool _hasValuesChanged(\r\n+    Map<String, double> current,\r\n+    Map<String, double> newValues,\r\n   ) {\r\n-    return baseValue * factor +\r\n-        _random.nextDouble() * fluctuation * 2 -\r\n-        fluctuation;\r\n+    return newValues.entries.any((entry) {\r\n+      final currentValue = current[entry.key];\r\n+      return currentValue == null ||\r\n+          (currentValue - entry.value).abs() > 0.0001;\r\n+    });\r\n   }\r\n \r\n-  String _getRandomComponent() {\r\n-    const components = [\r\n-      'Reaction Chamber',\r\n-      'MFC',\r\n-      'Vacuum Pump',\r\n-      'Pressure Control System',\r\n-    ];\r\n-    return components[_random.nextInt(components.length)];\r\n-  }\r\n-\r\n-  @override\r\n-  Future<void> close() {\r\n-    _simulationTimer?.cancel();\r\n-    return super.close();\r\n-  }\r\n-}\r\n-// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n-import 'dart:async';\r\n-import 'dart:math';\r\n-import 'package:bloc/bloc.dart';\r\n-import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n-import '../../component/bloc/component_bloc.dart';\r\n-import '../../component/bloc/component_event.dart';\r\n-import '../../alarm/bloc/alarm_bloc.dart';\r\n-import '../../alarm/bloc/alarm_event.dart';\r\n-import '../../safety/bloc/safety_bloc.dart';\r\n-import '../../safety/bloc/safety_event.dart';\r\n-import '../../utils/bloc_utils.dart';\r\n-import 'simulation_event.dart';\r\n-import 'simulation_state.dart';\r\n-\r\n-class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n-  final ComponentBloc _componentBloc;\r\n-  final AlarmBloc _alarmBloc;\r\n-  final SafetyBloc _safetyBloc;\r\n-  final Random _random; // Make Random injectable\r\n-  Timer? _simulationTimer;\r\n-\r\n-  static const int SIMULATION_INTERVAL_MS = 500;\r\n-\r\n-  SimulationBloc({\r\n-    required ComponentBloc componentBloc,\r\n-    required AlarmBloc alarmBloc,\r\n-    required SafetyBloc safetyBloc,\r\n-    Random? random, // Add optional random parameter\r\n-  })  : _componentBloc = componentBloc,\r\n-        _alarmBloc = alarmBloc,\r\n-        _safetyBloc = safetyBloc,\r\n-        _random = random ?? Random(), // Use provided random or create new one\r\n-        super(SimulationState.initial()) {\r\n-    on<StartSimulation>(_onStartSimulation);\r\n-    on<StopSimulation>(_onStopSimulation);\r\n-    on<SimulationTick>(_onSimulationTick);\r\n-    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n-    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n-    on<GenerateRandomError>(_onGenerateRandomError);\r\n-  }\r\n-\r\n-  Future<void> _onStartSimulation(\r\n-    StartSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status == SimulationStatus.running) return;\r\n-\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = Timer.periodic(\r\n-      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n-      (_) => add(SimulationTick()),\r\n-    );\r\n-\r\n-    final newState = state.copyWith(\r\n-      status: SimulationStatus.running,\r\n-      tickCount: 0,\r\n-      lastComponentUpdates: {},\r\n-    );\r\n-    emit(newState);\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation started',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onStopSimulation(\r\n-    StopSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status != SimulationStatus.running) return; // Add this check\r\n-\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = null;\r\n-\r\n-    final newState = state.copyWith(\r\n-      status: SimulationStatus.idle,\r\n-    );\r\n-    emit(newState); // Ensure state is emitted before adding alarm\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation stopped',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onGenerateRandomError(\r\n-    GenerateRandomError event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    final isComponentError =\r\n-        _random.nextBool(); // Randomly choose between component and safety error\r\n-\r\n-    if (isComponentError) {\r\n-      final componentName =\r\n-          _getRandomComponent(); // Use random component from available list\r\n-\r\n-      // Add error\r\n-      _componentBloc.add(ComponentErrorAdded(\r\n-        componentName,\r\n-        'Simulated malfunction detected',\r\n-      ));\r\n-\r\n-      // Update status\r\n-      final component = SystemComponent(\r\n-        name: componentName,\r\n-        description: '',\r\n-        currentValues: {},\r\n-        setValues: {},\r\n-      );\r\n-      component.status = ComponentStatus.error;\r\n-\r\n-      _componentBloc.add(ComponentStatusUpdated(\r\n-        componentName,\r\n-        component.status,\r\n-      ));\r\n-\r\n-      // Emit state to acknowledge error\r\n-      emit(state.copyWith(\r\n-        lastUpdated: DateTime.now(),\r\n-      ));\r\n-    } else {\r\n-      _safetyBloc.add(SafetyErrorDetected(\r\n-        SafetyError(\r\n-          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n-          description: 'Simulated safety error detected',\r\n-          severity: SafetyErrorSeverity.critical,\r\n-        ),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-\r\n-  Future<void> _onSimulationTick(\r\n-    SimulationTick event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status != SimulationStatus.running) return;\r\n-\r\n-    try {\r\n-      // Update component values\r\n-      final updates = _generateComponentUpdates();\r\n-      if (updates.isNotEmpty) {\r\n-        add(UpdateComponentValues(updates));\r\n-      }\r\n-\r\n-      // Check safety conditions\r\n-      add(CheckSafetyConditions());\r\n-\r\n-      // Occasionally generate random errors\r\n-      if (_random.nextDouble() < 0.05) {\r\n-        // 5% chance per tick\r\n-        add(GenerateRandomError());\r\n-      }\r\n-\r\n-      emit(state.copyWith(\r\n-        tickCount: state.tickCount + 1,\r\n-        lastUpdated: event.timestamp,\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(\r\n-        status: SimulationStatus.error,\r\n-        error: BlocUtils.handleError(error),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-  Future<void> _onUpdateComponentValues(\r\n-    UpdateComponentValues event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    try {\r\n-      // Update primary components\r\n-      for (var entry in event.updates.entries) {\r\n-        _componentBloc.add(ComponentValueUpdated(\r\n-          entry.key,\r\n-          entry.value,\r\n-        ));\r\n-      }\r\n-\r\n-      // Handle dependencies\r\n-      final dependencyUpdates = _processDependencies(event.updates);\r\n-      if (dependencyUpdates.isNotEmpty) {\r\n-        for (var entry in dependencyUpdates.entries) {\r\n-          _componentBloc.add(ComponentValueUpdated(\r\n-            entry.key,\r\n-            entry.value,\r\n-          ));\r\n-        }\r\n-      }\r\n-\r\n-      emit(state.copyWith(\r\n-        lastComponentUpdates: {\r\n-          ...state.lastComponentUpdates,\r\n-          for (var component in event.updates.keys) component: DateTime.now(),\r\n-        },\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n-    }\r\n-  }\r\n-\r\n-  Future<void> _onCheckSafetyConditions(\r\n-    CheckSafetyConditions event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    // Check chamber conditions\r\n-    _checkReactionChamber();\r\n-\r\n-    // Check other critical components\r\n-    _checkCriticalComponents();\r\n-  }\r\n-\r\n-  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n-    final updates = <String, Map<String, double>>{};\r\n-\r\n-    // Example component updates - you might want to adjust these based on your needs\r\n-    updates['Reaction Chamber'] = {\r\n-      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n-      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n-    };\r\n-\r\n-    updates['MFC'] = {\r\n-      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n-    };\r\n-\r\n-    return updates;\r\n-  }\r\n-\r\n   Map<String, Map<String, double>> _processDependencies(\r\n     Map<String, Map<String, double>> updates,\r\n   ) {\r\n     final dependencyUpdates = <String, Map<String, double>>{};\r\n \r\n     for (var entry in updates.entries) {\r\n       final dependencies = state.dependencies[entry.key] ?? [];\r\n-      for (var dependent in dependencies) {\r\n-        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n-          dependencyUpdates[dependent] = {\r\n-            'flow_rate': _adjustDependentValue(\r\n-              entry.value['flow_rate']!,\r\n-              0.8,\r\n-              0.2,\r\n-            ),\r\n-          };\r\n-        }\r\n-      }\r\n-    }\r\n \r\n-    return dependencyUpdates;\r\n-  }\r\n+      for (var dependentName in dependencies) {\r\n+        final behavior = state.componentBehaviors[dependentName];\r\n+        if (behavior != null) {\r\n+          final currentValues =\r\n+              _getComponentState(dependentName)?.currentValues ?? {};\r\n+          final newValues = behavior.generateValues(currentValues);\r\n \r\n-  void _checkReactionChamber() {\r\n-    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n-    // Add specific chamber checks here\r\n-  }\r\n+          // Apply dependency factors\r\n+          if (entry.key == 'MFC' &&\r\n+              dependentName == 'Nitrogen Generator' &&\r\n+              entry.value.containsKey('flow_rate')) {\r\n+            newValues['flow_rate'] = entry.value['flow_rate']! * 0.8;\r\n+          }\r\n \r\n-  void _checkCriticalComponents() {\r\n-    // Add checks for other critical components\r\n-  }\r\n-\r\n-  double _generateNewValue(\r\n-      String parameter, double setpoint, double fluctuation) {\r\n-    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n-    return setpoint + delta;\r\n-  }\r\n-\r\n-  double _adjustDependentValue(\r\n-    double baseValue,\r\n-    double factor,\r\n-    double fluctuation,\r\n-  ) {\r\n-    return baseValue * factor +\r\n-        _random.nextDouble() * fluctuation * 2 -\r\n-        fluctuation;\r\n-  }\r\n-\r\n-  String _getRandomComponent() {\r\n-    const components = [\r\n-      'Reaction Chamber',\r\n-      'MFC',\r\n-      'Vacuum Pump',\r\n-      'Pressure Control System',\r\n-    ];\r\n-    return components[_random.nextInt(components.length)];\r\n-  }\r\n-\r\n-  @override\r\n-  Future<void> close() {\r\n-    _simulationTimer?.cancel();\r\n-    return super.close();\r\n-  }\r\n-}\r\n-// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n-import 'dart:async';\r\n-import 'dart:math';\r\n-import 'package:bloc/bloc.dart';\r\n-import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n-import '../../component/bloc/component_bloc.dart';\r\n-import '../../component/bloc/component_event.dart';\r\n-import '../../alarm/bloc/alarm_bloc.dart';\r\n-import '../../alarm/bloc/alarm_event.dart';\r\n-import '../../safety/bloc/safety_bloc.dart';\r\n-import '../../safety/bloc/safety_event.dart';\r\n-import '../../utils/bloc_utils.dart';\r\n-import 'simulation_event.dart';\r\n-import 'simulation_state.dart';\r\n-\r\n-class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n-  final ComponentBloc _componentBloc;\r\n-  final AlarmBloc _alarmBloc;\r\n-  final SafetyBloc _safetyBloc;\r\n-  final Random _random; // Make Random injectable\r\n-  Timer? _simulationTimer;\r\n-\r\n-  static const int SIMULATION_INTERVAL_MS = 500;\r\n-\r\n-  SimulationBloc({\r\n-    required ComponentBloc componentBloc,\r\n-    required AlarmBloc alarmBloc,\r\n-    required SafetyBloc safetyBloc,\r\n-    Random? random, // Add optional random parameter\r\n-  })  : _componentBloc = componentBloc,\r\n-        _alarmBloc = alarmBloc,\r\n-        _safetyBloc = safetyBloc,\r\n-        _random = random ?? Random(), // Use provided random or create new one\r\n-        super(SimulationState.initial()) {\r\n-    on<StartSimulation>(_onStartSimulation);\r\n-    on<StopSimulation>(_onStopSimulation);\r\n-    on<SimulationTick>(_onSimulationTick);\r\n-    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n-    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n-    on<GenerateRandomError>(_onGenerateRandomError);\r\n-  }\r\n-\r\n-  Future<void> _onStartSimulation(\r\n-    StartSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status == SimulationStatus.running) return;\r\n-\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = Timer.periodic(\r\n-      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n-      (_) => add(SimulationTick()),\r\n-    );\r\n-\r\n-    final newState = state.copyWith(\r\n-      status: SimulationStatus.running,\r\n-      tickCount: 0,\r\n-      lastComponentUpdates: {},\r\n-    );\r\n-    emit(newState);\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation started',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onStopSimulation(\r\n-    StopSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status != SimulationStatus.running) return; // Add this check\r\n-\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = null;\r\n-\r\n-    final newState = state.copyWith(\r\n-      status: SimulationStatus.idle,\r\n-    );\r\n-    emit(newState); // Ensure state is emitted before adding alarm\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation stopped',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onGenerateRandomError(\r\n-    GenerateRandomError event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    final isComponentError =\r\n-        true; // Force component error for predictable testing\r\n-\r\n-    if (isComponentError) {\r\n-      final componentName =\r\n-          'Reaction Chamber'; // Use fixed component for testing\r\n-\r\n-      // Add error\r\n-      _componentBloc.add(ComponentErrorAdded(\r\n-        componentName,\r\n-        'Simulated malfunction detected',\r\n-      ));\r\n-\r\n-      // Update status\r\n-      final component = SystemComponent(\r\n-        name: componentName,\r\n-        description: '',\r\n-        currentValues: {},\r\n-        setValues: {},\r\n-      );\r\n-      component.status = ComponentStatus.error;\r\n-\r\n-      _componentBloc.add(ComponentStatusUpdated(\r\n-        componentName,\r\n-        component.status,\r\n-      ));\r\n-\r\n-      // Emit state to acknowledge error\r\n-      emit(state.copyWith(\r\n-        lastUpdated: DateTime.now(),\r\n-      ));\r\n-    } else {\r\n-      _safetyBloc.add(SafetyErrorDetected(\r\n-        SafetyError(\r\n-          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n-          description: 'Simulated safety error detected',\r\n-          severity: SafetyErrorSeverity.critical,\r\n-        ),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-\r\n-  Future<void> _onSimulationTick(\r\n-    SimulationTick event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status != SimulationStatus.running) return;\r\n-\r\n-    try {\r\n-      // Update component values\r\n-      final updates = _generateComponentUpdates();\r\n-      if (updates.isNotEmpty) {\r\n-        add(UpdateComponentValues(updates));\r\n-      }\r\n-\r\n-      // Check safety conditions\r\n-      add(CheckSafetyConditions());\r\n-\r\n-      // Occasionally generate random errors\r\n-      if (_random.nextDouble() < 0.05) {\r\n-        // 5% chance per tick\r\n-        add(GenerateRandomError());\r\n-      }\r\n-\r\n-      emit(state.copyWith(\r\n-        tickCount: state.tickCount + 1,\r\n-        lastUpdated: event.timestamp,\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(\r\n-        status: SimulationStatus.error,\r\n-        error: BlocUtils.handleError(error),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-  Future<void> _onUpdateComponentValues(\r\n-    UpdateComponentValues event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    try {\r\n-      // Update primary components\r\n-      for (var entry in event.updates.entries) {\r\n-        _componentBloc.add(ComponentValueUpdated(\r\n-          entry.key,\r\n-          entry.value,\r\n-        ));\r\n-      }\r\n-\r\n-      // Handle dependencies\r\n-      final dependencyUpdates = _processDependencies(event.updates);\r\n-      if (dependencyUpdates.isNotEmpty) {\r\n-        for (var entry in dependencyUpdates.entries) {\r\n-          _componentBloc.add(ComponentValueUpdated(\r\n-            entry.key,\r\n-            entry.value,\r\n-          ));\r\n+          if (behavior.validateValues(newValues)) {\r\n+            dependencyUpdates[dependentName] = newValues;\r\n+          }\r\n         }\r\n       }\r\n-\r\n-      emit(state.copyWith(\r\n-        lastComponentUpdates: {\r\n-          ...state.lastComponentUpdates,\r\n-          for (var component in event.updates.keys) component: DateTime.now(),\r\n-        },\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n     }\r\n-  }\r\n \r\n-  Future<void> _onCheckSafetyConditions(\r\n-    CheckSafetyConditions event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    // Check chamber conditions\r\n-    _checkReactionChamber();\r\n-\r\n-    // Check other critical components\r\n-    _checkCriticalComponents();\r\n-  }\r\n-\r\n-  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n-    final updates = <String, Map<String, double>>{};\r\n-\r\n-    // Example component updates - you might want to adjust these based on your needs\r\n-    updates['Reaction Chamber'] = {\r\n-      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n-      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n-    };\r\n-\r\n-    updates['MFC'] = {\r\n-      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n-    };\r\n-\r\n-    return updates;\r\n-  }\r\n-\r\n-  Map<String, Map<String, double>> _processDependencies(\r\n-    Map<String, Map<String, double>> updates,\r\n-  ) {\r\n-    final dependencyUpdates = <String, Map<String, double>>{};\r\n-\r\n-    for (var entry in updates.entries) {\r\n-      final dependencies = state.dependencies[entry.key] ?? [];\r\n-      for (var dependent in dependencies) {\r\n-        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n-          dependencyUpdates[dependent] = {\r\n-            'flow_rate': _adjustDependentValue(\r\n-              entry.value['flow_rate']!,\r\n-              0.8,\r\n-              0.2,\r\n-            ),\r\n-          };\r\n-        }\r\n-      }\r\n-    }\r\n-\r\n     return dependencyUpdates;\r\n   }\r\n \r\n   void _checkReactionChamber() {\r\n-    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n-    // Add specific chamber checks here\r\n-  }\r\n+    final behavior =\r\n+        state.componentBehaviors['Reaction Chamber'] as ReactorChamberBehavior?;\r\n+    if (behavior == null) return;\r\n \r\n-  void _checkCriticalComponents() {\r\n-    // Add checks for other critical components\r\n-  }\r\n-\r\n-  double _generateNewValue(\r\n-      String parameter, double setpoint, double fluctuation) {\r\n-    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n-    return setpoint + delta;\r\n-  }\r\n-\r\n-  double _adjustDependentValue(\r\n-    double baseValue,\r\n-    double factor,\r\n-    double fluctuation,\r\n-  ) {\r\n-    return baseValue * factor +\r\n-        _random.nextDouble() * fluctuation * 2 -\r\n-        fluctuation;\r\n-  }\r\n-\r\n-  String _getRandomComponent() {\r\n-    const components = [\r\n-      'Reaction Chamber',\r\n-      'MFC',\r\n-      'Vacuum Pump',\r\n-      'Pressure Control System',\r\n-    ];\r\n-    return components[_random.nextInt(components.length)];\r\n-  }\r\n-\r\n-  @override\r\n-  Future<void> close() {\r\n-    _simulationTimer?.cancel();\r\n-    return super.close();\r\n-  }\r\n-}\r\n-// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n-import 'dart:async';\r\n-import 'dart:math';\r\n-import 'package:bloc/bloc.dart';\r\n-import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n-import '../../component/bloc/component_bloc.dart';\r\n-import '../../component/bloc/component_event.dart';\r\n-import '../../alarm/bloc/alarm_bloc.dart';\r\n-import '../../alarm/bloc/alarm_event.dart';\r\n-import '../../safety/bloc/safety_bloc.dart';\r\n-import '../../safety/bloc/safety_event.dart';\r\n-import '../../utils/bloc_utils.dart';\r\n-import 'simulation_event.dart';\r\n-import 'simulation_state.dart';\r\n-\r\n-class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n-  final ComponentBloc _componentBloc;\r\n-  final AlarmBloc _alarmBloc;\r\n-  final SafetyBloc _safetyBloc;\r\n-  final Random _random; // Make Random injectable\r\n-  Timer? _simulationTimer;\r\n-\r\n-  static const int SIMULATION_INTERVAL_MS = 500;\r\n-\r\n-  SimulationBloc({\r\n-    required ComponentBloc componentBloc,\r\n-    required AlarmBloc alarmBloc,\r\n-    required SafetyBloc safetyBloc,\r\n-    Random? random, // Add optional random parameter\r\n-  })  : _componentBloc = componentBloc,\r\n-        _alarmBloc = alarmBloc,\r\n-        _safetyBloc = safetyBloc,\r\n-        _random = random ?? Random(), // Use provided random or create new one\r\n-        super(SimulationState.initial()) {\r\n-    on<StartSimulation>(_onStartSimulation);\r\n-    on<StopSimulation>(_onStopSimulation);\r\n-    on<SimulationTick>(_onSimulationTick);\r\n-    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n-    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n-    on<GenerateRandomError>(_onGenerateRandomError);\r\n-  }\r\n-\r\n-  Future<void> _onStartSimulation(\r\n-    StartSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status == SimulationStatus.running) return;\r\n-\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = Timer.periodic(\r\n-      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n-      (_) => add(SimulationTick()),\r\n-    );\r\n-\r\n-    final newState = state.copyWith(\r\n-      status: SimulationStatus.running,\r\n-      tickCount: 0,\r\n-      lastComponentUpdates: {},\r\n-    );\r\n-    emit(newState);\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation started',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onStopSimulation(\r\n-    StopSimulation event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status != SimulationStatus.running) return; // Add this check\r\n-\r\n-    _simulationTimer?.cancel();\r\n-    _simulationTimer = null;\r\n-\r\n-    final newState = state.copyWith(\r\n-      status: SimulationStatus.idle,\r\n-    );\r\n-    emit(newState); // Ensure state is emitted before adding alarm\r\n-\r\n-    _alarmBloc.add(AddAlarm(\r\n-      message: 'Simulation stopped',\r\n-      severity: AlarmSeverity.info,\r\n-    ));\r\n-  }\r\n-\r\n-  Future<void> _onGenerateRandomError(\r\n-    GenerateRandomError event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    final isComponentError =\r\n-        true; // Force component error for predictable testing\r\n-\r\n-    if (isComponentError) {\r\n-      final componentName =\r\n-          'Reaction Chamber'; // Use fixed component for testing\r\n-\r\n-      // Add error\r\n-      _componentBloc.add(ComponentErrorAdded(\r\n-        componentName,\r\n-        'Simulated malfunction detected',\r\n-      ));\r\n-\r\n-      // Update status\r\n-      final component = SystemComponent(\r\n-        name: componentName,\r\n-        description: '',\r\n-        currentValues: {},\r\n-        setValues: {},\r\n-      );\r\n-      component.status = ComponentStatus.error;\r\n-\r\n-      _componentBloc.add(ComponentStatusUpdated(\r\n-        componentName,\r\n-        component.status,\r\n-      ));\r\n-\r\n-      // Emit state to acknowledge error\r\n-      emit(state.copyWith(\r\n-        lastUpdated: DateTime.now(),\r\n-      ));\r\n-    } else {\r\n-      _safetyBloc.add(SafetyErrorDetected(\r\n-        SafetyError(\r\n-          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n-          description: 'Simulated safety error detected',\r\n-          severity: SafetyErrorSeverity.critical,\r\n-        ),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-  Future<void> _onSimulationTick(\r\n-    SimulationTick event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    if (state.status != SimulationStatus.running) return;\r\n-\r\n-    try {\r\n-      // Update component values\r\n-      final updates = _generateComponentUpdates();\r\n-      if (updates.isNotEmpty) {\r\n-        add(UpdateComponentValues(updates));\r\n-      }\r\n-\r\n-      // Check safety conditions\r\n-      add(CheckSafetyConditions());\r\n-\r\n-      // Occasionally generate random errors\r\n-      if (_random.nextDouble() < 0.05) {\r\n-        // 5% chance per tick\r\n-        add(GenerateRandomError());\r\n-      }\r\n-\r\n-      emit(state.copyWith(\r\n-        tickCount: state.tickCount + 1,\r\n-        lastUpdated: event.timestamp,\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(\r\n-        status: SimulationStatus.error,\r\n-        error: BlocUtils.handleError(error),\r\n-      ));\r\n-    }\r\n-  }\r\n-\r\n-  Future<void> _onUpdateComponentValues(\r\n-    UpdateComponentValues event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    try {\r\n-      // Update primary components\r\n-      for (var entry in event.updates.entries) {\r\n-        _componentBloc.add(ComponentValueUpdated(\r\n-          entry.key,\r\n-          entry.value,\r\n+    final chamber = _getComponentState('Reaction Chamber');\r\n+    if (chamber != null) {\r\n+      final values = chamber.currentValues;\r\n+      if (!behavior.validateValues(values)) {\r\n+        _safetyBloc.add(SafetyErrorDetected(\r\n+          SafetyError(\r\n+            id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+            description: 'Reaction chamber parameters out of safe range',\r\n+            severity: SafetyErrorSeverity.critical,\r\n+          ),\r\n         ));\r\n       }\r\n-\r\n-      // Handle dependencies\r\n-      final dependencyUpdates = _processDependencies(event.updates);\r\n-      if (dependencyUpdates.isNotEmpty) {\r\n-        for (var entry in dependencyUpdates.entries) {\r\n-          _componentBloc.add(ComponentValueUpdated(\r\n-            entry.key,\r\n-            entry.value,\r\n-          ));\r\n-        }\r\n-      }\r\n-\r\n-      emit(state.copyWith(\r\n-        lastComponentUpdates: {\r\n-          ...state.lastComponentUpdates,\r\n-          for (var component in event.updates.keys) component: DateTime.now(),\r\n-        },\r\n-      ));\r\n-    } catch (error) {\r\n-      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n     }\r\n   }\r\n \r\n-  Future<void> _onCheckSafetyConditions(\r\n-    CheckSafetyConditions event,\r\n-    Emitter<SimulationState> emit,\r\n-  ) async {\r\n-    // Check chamber conditions\r\n-    _checkReactionChamber();\r\n-\r\n-    // Check other critical components\r\n-    _checkCriticalComponents();\r\n-  }\r\n-\r\n-  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n-    final updates = <String, Map<String, double>>{};\r\n-\r\n-    // Example component updates - you might want to adjust these based on your needs\r\n-    updates['Reaction Chamber'] = {\r\n-      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n-      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n-    };\r\n-\r\n-    updates['MFC'] = {\r\n-      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n-    };\r\n-\r\n-    return updates;\r\n-  }\r\n-\r\n-  Map<String, Map<String, double>> _processDependencies(\r\n-    Map<String, Map<String, double>> updates,\r\n-  ) {\r\n-    final dependencyUpdates = <String, Map<String, double>>{};\r\n-\r\n-    for (var entry in updates.entries) {\r\n-      final dependencies = state.dependencies[entry.key] ?? [];\r\n-      for (var dependent in dependencies) {\r\n-        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n-          dependencyUpdates[dependent] = {\r\n-            'flow_rate': _adjustDependentValue(\r\n-              entry.value['flow_rate']!,\r\n-              0.8,\r\n-              0.2,\r\n-            ),\r\n-          };\r\n+  void _checkCriticalComponents() {\r\n+    for (var entry in state.componentBehaviors.entries) {\r\n+      if (_isCriticalComponent(entry.key)) {\r\n+        final component = _getComponentState(entry.key);\r\n+        if (component != null) {\r\n+          if (!entry.value.validateValues(component.currentValues)) {\r\n+            _safetyBloc.add(SafetyErrorDetected(\r\n+              SafetyError(\r\n+                id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+                description: '${entry.key} parameters out of safe range',\r\n+                severity: SafetyErrorSeverity.warning,\r\n+              ),\r\n+            ));\r\n+          }\r\n         }\r\n       }\r\n     }\r\n-\r\n-    return dependencyUpdates;\r\n   }\r\n \r\n-  void _checkReactionChamber() {\r\n-    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n-    // Add specific chamber checks here\r\n+  bool _isCriticalComponent(String componentName) {\r\n+    return [\r\n+      'MFC',\r\n+      'Pressure Control System',\r\n+      'Vacuum Pump',\r\n+    ].contains(componentName);\r\n   }\r\n \r\n-  void _checkCriticalComponents() {\r\n-    // Add checks for other critical components\r\n-  }\r\n-\r\n   double _generateNewValue(\r\n       String parameter, double setpoint, double fluctuation) {\r\n     double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n     return setpoint + delta;\r\n"
                },
                {
                    "date": 1734073076748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,19 +2,19 @@\n import 'dart:async';\r\n import 'dart:math';\r\n import 'package:bloc/bloc.dart';\r\n import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\n-import '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\n-import '../../component/bloc/component_bloc.dart';\r\n-import '../../component/bloc/component_event.dart';\r\n-import '../../alarm/bloc/alarm_bloc.dart';\r\n-import '../../alarm/bloc/alarm_event.dart';\r\n-import '../../safety/bloc/safety_bloc.dart';\r\n-import '../../safety/bloc/safety_event.dart';\r\n-import '../../utils/bloc_utils.dart';\r\n-import 'simulation_event.dart';\r\n-import 'simulation_state.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/alarm.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/safety_error.dart';\r\n+import 'package:experiment_planner/blocs/component/bloc/component_bloc.dart';\r\n+import 'package:experiment_planner/blocs/component/bloc/component_event.dart';\r\n+import 'package:experiment_planner/blocs/alarm/bloc/alarm_bloc.dart';\r\n+import 'package:experiment_planner/blocs/alarm/bloc/alarm_event.dart';\r\n+import 'package:experiment_planner/blocs/safety/bloc/safety_bloc.dart';\r\n+import 'package:experiment_planner/blocs/safety/bloc/safety_event.dart';\r\n+import 'package:experiment_planner/blocs/utils/bloc_utils.dart';\r\n+import 'package:experiment_planner/blocs/simulation/bloc/simulation_event.dart';\r\n+import 'package:experiment_planner/blocs/simulation/bloc/simulation_state.dart';\r\n \r\n class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n   final ComponentBloc _componentBloc;\r\n   final AlarmBloc _alarmBloc;\r\n"
                },
                {
                    "date": 1734073081976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,366 @@\n+// lib/blocs/simulation/bloc/simulation_bloc.dart\r\n+import 'dart:async';\r\n+import 'dart:math';\r\n+import 'package:bloc/bloc.dart';\r\n+import 'package:experiment_planner/blocs/simulation/models/component_simulation_behavior.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/system_component.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/alarm.dart';\r\n+import 'package:experiment_planner/modules/system_operation_also_main_module/models/safety_error.dart';\r\n+import 'package:experiment_planner/blocs/component/bloc/component_bloc.dart';\r\n+import 'package:experiment_planner/blocs/component/bloc/component_event.dart';\r\n+import 'package:experiment_planner/blocs/alarm/bloc/alarm_bloc.dart';\r\n+import 'package:experiment_planner/blocs/alarm/bloc/alarm_event.dart';\r\n+import 'package:experiment_planner/blocs/safety/bloc/safety_bloc.dart';\r\n+import 'package:experiment_planner/blocs/safety/bloc/safety_event.dart';\r\n+import 'package:experiment_planner/blocs/utils/bloc_utils.dart';\r\n+import 'package:experiment_planner/blocs/simulation/bloc/simulation_event.dart';\r\n+import 'package:experiment_planner/blocs/simulation/bloc/simulation_state.dart';\r\n+\r\n+class SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n+  final ComponentBloc _componentBloc;\r\n+  final AlarmBloc _alarmBloc;\r\n+  final SafetyBloc _safetyBloc;\r\n+  final Random _random; // Make Random injectable\r\n+  Timer? _simulationTimer;\r\n+\r\n+  static const int SIMULATION_INTERVAL_MS = 500;\r\n+\r\n+  SimulationBloc({\r\n+    required ComponentBloc componentBloc,\r\n+    required AlarmBloc alarmBloc,\r\n+    required SafetyBloc safetyBloc,\r\n+    Random? random, // Add optional random parameter\r\n+  })  : _componentBloc = componentBloc,\r\n+        _alarmBloc = alarmBloc,\r\n+        _safetyBloc = safetyBloc,\r\n+        _random = random ?? Random(), // Use provided random or create new one\r\n+        super(SimulationState.initial()) {\r\n+    on<StartSimulation>(_onStartSimulation);\r\n+    on<StopSimulation>(_onStopSimulation);\r\n+    on<SimulationTick>(_onSimulationTick);\r\n+    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n+    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n+    on<GenerateRandomError>(_onGenerateRandomError);\r\n+  }\r\n+\r\n+  Future<void> _onStartSimulation(\r\n+    StartSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status == SimulationStatus.running) return;\r\n+\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = Timer.periodic(\r\n+      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n+      (_) => add(SimulationTick()),\r\n+    );\r\n+\r\n+    final newState = state.copyWith(\r\n+      status: SimulationStatus.running,\r\n+      tickCount: 0,\r\n+      lastComponentUpdates: {},\r\n+    );\r\n+    emit(newState);\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation started',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onStopSimulation(\r\n+    StopSimulation event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    _simulationTimer?.cancel();\r\n+    _simulationTimer = null;\r\n+\r\n+    // Important: emit state before adding alarm\r\n+    emit(state.copyWith(\r\n+      status: SimulationStatus.idle,\r\n+      lastUpdated: DateTime.now(),\r\n+    ));\r\n+\r\n+    _alarmBloc.add(AddAlarm(\r\n+      message: 'Simulation stopped',\r\n+      severity: AlarmSeverity.info,\r\n+    ));\r\n+  }\r\n+\r\n+  Future<void> _onGenerateRandomError(\r\n+    GenerateRandomError event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    final isComponentError = _random.nextBool();\r\n+\r\n+    // Always emit a state to acknowledge the event\r\n+    emit(state.copyWith(\r\n+      lastUpdated: DateTime.now(),\r\n+    ));\r\n+\r\n+    if (isComponentError) {\r\n+      final componentName = _getRandomComponent();\r\n+      _componentBloc.add(ComponentErrorAdded(\r\n+        componentName,\r\n+        'Simulated malfunction detected',\r\n+      ));\r\n+\r\n+      final component = SystemComponent(\r\n+        name: componentName,\r\n+        description: '',\r\n+        currentValues: {},\r\n+        setValues: {},\r\n+      );\r\n+      component.status = ComponentStatus.error;\r\n+\r\n+      _componentBloc.add(ComponentStatusUpdated(\r\n+        componentName,\r\n+        component.status,\r\n+      ));\r\n+    } else {\r\n+      _safetyBloc.add(SafetyErrorDetected(\r\n+        SafetyError(\r\n+          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+          description: 'Simulated safety error detected',\r\n+          severity: _random.nextBool()\r\n+              ? SafetyErrorSeverity.warning\r\n+              : SafetyErrorSeverity.critical,\r\n+        ),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onSimulationTick(\r\n+    SimulationTick event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    if (state.status != SimulationStatus.running) return;\r\n+\r\n+    try {\r\n+      // Update component values\r\n+      final updates = _generateComponentUpdates();\r\n+      if (updates.isNotEmpty) {\r\n+        add(UpdateComponentValues(updates));\r\n+      }\r\n+\r\n+      // Check safety conditions\r\n+      add(CheckSafetyConditions());\r\n+\r\n+      // Occasionally generate random errors\r\n+      if (_random.nextDouble() < 0.05) {\r\n+        // 5% chance per tick\r\n+        add(GenerateRandomError());\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        tickCount: state.tickCount + 1,\r\n+        lastUpdated: event.timestamp,\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(\r\n+        status: SimulationStatus.error,\r\n+        error: BlocUtils.handleError(error),\r\n+      ));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onUpdateComponentValues(\r\n+    UpdateComponentValues event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    try {\r\n+      // Update primary components\r\n+      for (var entry in event.updates.entries) {\r\n+        _componentBloc.add(ComponentValueUpdated(\r\n+          entry.key,\r\n+          entry.value,\r\n+        ));\r\n+      }\r\n+\r\n+      // Handle dependencies\r\n+      final dependencyUpdates = _processDependencies(event.updates);\r\n+      if (dependencyUpdates.isNotEmpty) {\r\n+        for (var entry in dependencyUpdates.entries) {\r\n+          _componentBloc.add(ComponentValueUpdated(\r\n+            entry.key,\r\n+            entry.value,\r\n+          ));\r\n+        }\r\n+      }\r\n+\r\n+      emit(state.copyWith(\r\n+        lastComponentUpdates: {\r\n+          ...state.lastComponentUpdates,\r\n+          for (var component in event.updates.keys) component: DateTime.now(),\r\n+        },\r\n+      ));\r\n+    } catch (error) {\r\n+      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n+    }\r\n+  }\r\n+\r\n+  Future<void> _onCheckSafetyConditions(\r\n+    CheckSafetyConditions event,\r\n+    Emitter<SimulationState> emit,\r\n+  ) async {\r\n+    // Check chamber conditions\r\n+    _checkReactionChamber();\r\n+\r\n+    // Check other critical components\r\n+    _checkCriticalComponents();\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n+    final updates = <String, Map<String, double>>{};\r\n+\r\n+    for (var entry in state.componentBehaviors.entries) {\r\n+      final componentName = entry.key;\r\n+      final behavior = entry.value;\r\n+\r\n+      // Get current values from component\r\n+      final component = _getComponentState(componentName);\r\n+      if (component != null && component.isActivated) {\r\n+        final newValues = behavior.generateValues(component.currentValues);\r\n+\r\n+        // Only include if values changed and are valid\r\n+        if (_hasValuesChanged(component.currentValues, newValues) &&\r\n+            behavior.validateValues(newValues)) {\r\n+          updates[componentName] = newValues;\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    return updates;\r\n+  }\r\n+\r\n+  SystemComponent? _getComponentState(String componentName) {\r\n+    try {\r\n+      _componentBloc.add(ComponentInitialized(componentName));\r\n+      return _componentBloc.state.component;\r\n+    } catch (e) {\r\n+      return null;\r\n+    }\r\n+  }\r\n+\r\n+  bool _hasValuesChanged(\r\n+    Map<String, double> current,\r\n+    Map<String, double> newValues,\r\n+  ) {\r\n+    return newValues.entries.any((entry) {\r\n+      final currentValue = current[entry.key];\r\n+      return currentValue == null ||\r\n+          (currentValue - entry.value).abs() > 0.0001;\r\n+    });\r\n+  }\r\n+\r\n+  Map<String, Map<String, double>> _processDependencies(\r\n+    Map<String, Map<String, double>> updates,\r\n+  ) {\r\n+    final dependencyUpdates = <String, Map<String, double>>{};\r\n+\r\n+    for (var entry in updates.entries) {\r\n+      final dependencies = state.dependencies[entry.key] ?? [];\r\n+\r\n+      for (var dependentName in dependencies) {\r\n+        final behavior = state.componentBehaviors[dependentName];\r\n+        if (behavior != null) {\r\n+          final currentValues =\r\n+              _getComponentState(dependentName)?.currentValues ?? {};\r\n+          final newValues = behavior.generateValues(currentValues);\r\n+\r\n+          // Apply dependency factors\r\n+          if (entry.key == 'MFC' &&\r\n+              dependentName == 'Nitrogen Generator' &&\r\n+              entry.value.containsKey('flow_rate')) {\r\n+            newValues['flow_rate'] = entry.value['flow_rate']! * 0.8;\r\n+          }\r\n+\r\n+          if (behavior.validateValues(newValues)) {\r\n+            dependencyUpdates[dependentName] = newValues;\r\n+          }\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    return dependencyUpdates;\r\n+  }\r\n+\r\n+  void _checkReactionChamber() {\r\n+    final behavior =\r\n+        state.componentBehaviors['Reaction Chamber'] as ReactorChamberBehavior?;\r\n+    if (behavior == null) return;\r\n+\r\n+    final chamber = _getComponentState('Reaction Chamber');\r\n+    if (chamber != null) {\r\n+      final values = chamber.currentValues;\r\n+      if (!behavior.validateValues(values)) {\r\n+        _safetyBloc.add(SafetyErrorDetected(\r\n+          SafetyError(\r\n+            id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+            description: 'Reaction chamber parameters out of safe range',\r\n+            severity: SafetyErrorSeverity.critical,\r\n+          ),\r\n+        ));\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  void _checkCriticalComponents() {\r\n+    for (var entry in state.componentBehaviors.entries) {\r\n+      if (_isCriticalComponent(entry.key)) {\r\n+        final component = _getComponentState(entry.key);\r\n+        if (component != null) {\r\n+          if (!entry.value.validateValues(component.currentValues)) {\r\n+            _safetyBloc.add(SafetyErrorDetected(\r\n+              SafetyError(\r\n+                id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n+                description: '${entry.key} parameters out of safe range',\r\n+                severity: SafetyErrorSeverity.warning,\r\n+              ),\r\n+            ));\r\n+          }\r\n+        }\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  bool _isCriticalComponent(String componentName) {\r\n+    return [\r\n+      'MFC',\r\n+      'Pressure Control System',\r\n+      'Vacuum Pump',\r\n+    ].contains(componentName);\r\n+  }\r\n+\r\n+  double _generateNewValue(\r\n+      String parameter, double setpoint, double fluctuation) {\r\n+    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n+    return setpoint + delta;\r\n+  }\r\n+\r\n+  double _adjustDependentValue(\r\n+    double baseValue,\r\n+    double factor,\r\n+    double fluctuation,\r\n+  ) {\r\n+    return baseValue * factor +\r\n+        _random.nextDouble() * fluctuation * 2 -\r\n+        fluctuation;\r\n+  }\r\n+\r\n+  String _getRandomComponent() {\r\n+    const components = [\r\n+      'Reaction Chamber',\r\n+      'MFC',\r\n+      'Vacuum Pump',\r\n+      'Pressure Control System',\r\n+    ];\r\n+    return components[_random.nextInt(components.length)];\r\n+  }\r\n+\r\n+  @override\r\n+  Future<void> close() {\r\n+    _simulationTimer?.cancel();\r\n+    return super.close();\r\n+  }\r\n+}\r\n"
                }
            ],
            "date": 1734062456976,
            "name": "Commit-0",
            "content": "// lib/blocs/simulation/bloc/simulation_bloc.dart\r\nimport 'dart:async';\r\nimport 'dart:math';\r\nimport 'package:bloc/bloc.dart';\r\nimport '../../../modules/system_operation_also_main_module/models/alarm.dart';\r\nimport '../../../modules/system_operation_also_main_module/models/safety_error.dart';\r\nimport '../../component/bloc/component_bloc.dart';\r\nimport '../../component/bloc/component_event.dart';\r\nimport '../../alarm/bloc/alarm_bloc.dart';\r\nimport '../../alarm/bloc/alarm_event.dart';\r\nimport '../../safety/bloc/safety_bloc.dart';\r\nimport '../../safety/bloc/safety_event.dart';\r\nimport '../../utils/bloc_utils.dart';\r\nimport 'simulation_event.dart';\r\nimport 'simulation_state.dart';\r\n\r\nclass SimulationBloc extends Bloc<SimulationEvent, SimulationState> {\r\n  final ComponentBloc _componentBloc;\r\n  final AlarmBloc _alarmBloc;\r\n  final SafetyBloc _safetyBloc;\r\n  final Random _random = Random();\r\n  Timer? _simulationTimer;\r\n\r\n  static const int SIMULATION_INTERVAL_MS = 500;\r\n\r\n  SimulationBloc({\r\n    required ComponentBloc componentBloc,\r\n    required AlarmBloc alarmBloc,\r\n    required SafetyBloc safetyBloc,\r\n  })  : _componentBloc = componentBloc,\r\n        _alarmBloc = alarmBloc,\r\n        _safetyBloc = safetyBloc,\r\n        super(SimulationState.initial()) {\r\n    on<StartSimulation>(_onStartSimulation);\r\n    on<StopSimulation>(_onStopSimulation);\r\n    on<SimulationTick>(_onSimulationTick);\r\n    on<UpdateComponentValues>(_onUpdateComponentValues);\r\n    on<CheckSafetyConditions>(_onCheckSafetyConditions);\r\n    on<GenerateRandomError>(_onGenerateRandomError);\r\n  }\r\n\r\n  Future<void> _onStartSimulation(\r\n    StartSimulation event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    if (state.status == SimulationStatus.running) return;\r\n\r\n    _simulationTimer?.cancel();\r\n    _simulationTimer = Timer.periodic(\r\n      const Duration(milliseconds: SIMULATION_INTERVAL_MS),\r\n      (_) => add(SimulationTick()),\r\n    );\r\n\r\n    emit(state.copyWith(\r\n      status: SimulationStatus.running,\r\n      tickCount: 0,\r\n      lastComponentUpdates: {},\r\n    ));\r\n\r\n    _alarmBloc.add(AddAlarm(\r\n      message: 'Simulation started',\r\n      severity: AlarmSeverity.info,\r\n    ));\r\n  }\r\n\r\n  Future<void> _onStopSimulation(\r\n    StopSimulation event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    _simulationTimer?.cancel();\r\n    _simulationTimer = null;\r\n\r\n    emit(state.copyWith(\r\n      status: SimulationStatus.idle,\r\n    ));\r\n\r\n    _alarmBloc.add(AddAlarm(\r\n      message: 'Simulation stopped',\r\n      severity: AlarmSeverity.info,\r\n    ));\r\n  }\r\n\r\n  Future<void> _onSimulationTick(\r\n    SimulationTick event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    if (state.status != SimulationStatus.running) return;\r\n\r\n    try {\r\n      // Update component values\r\n      final updates = _generateComponentUpdates();\r\n      if (updates.isNotEmpty) {\r\n        add(UpdateComponentValues(updates));\r\n      }\r\n\r\n      // Check safety conditions\r\n      add(CheckSafetyConditions());\r\n\r\n      // Occasionally generate random errors\r\n      if (_random.nextDouble() < 0.05) { // 5% chance per tick\r\n        add(GenerateRandomError());\r\n      }\r\n\r\n      emit(state.copyWith(\r\n        tickCount: state.tickCount + 1,\r\n        lastUpdated: event.timestamp,\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(\r\n        status: SimulationStatus.error,\r\n        error: BlocUtils.handleError(error),\r\n      ));\r\n    }\r\n  }\r\n\r\n  Future<void> _onUpdateComponentValues(\r\n    UpdateComponentValues event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    try {\r\n      // Update primary components\r\n      for (var entry in event.updates.entries) {\r\n        _componentBloc.add(ComponentValueUpdated(\r\n          entry.key,\r\n          entry.value,\r\n        ));\r\n      }\r\n\r\n      // Handle dependencies\r\n      final dependencyUpdates = _processDependencies(event.updates);\r\n      if (dependencyUpdates.isNotEmpty) {\r\n        for (var entry in dependencyUpdates.entries) {\r\n          _componentBloc.add(ComponentValueUpdated(\r\n            entry.key,\r\n            entry.value,\r\n          ));\r\n        }\r\n      }\r\n\r\n      emit(state.copyWith(\r\n        lastComponentUpdates: {\r\n          ...state.lastComponentUpdates,\r\n          for (var component in event.updates.keys)\r\n            component: DateTime.now(),\r\n        },\r\n      ));\r\n    } catch (error) {\r\n      emit(state.copyWith(error: BlocUtils.handleError(error)));\r\n    }\r\n  }\r\n\r\n  Future<void> _onCheckSafetyConditions(\r\n    CheckSafetyConditions event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    // Check chamber conditions\r\n    _checkReactionChamber();\r\n\r\n    // Check other critical components\r\n    _checkCriticalComponents();\r\n  }\r\n\r\n  Future<void> _onGenerateRandomError(\r\n    GenerateRandomError event,\r\n    Emitter<SimulationState> emit,\r\n  ) async {\r\n    if (_random.nextBool()) {\r\n      // Component malfunction\r\n      final componentName = _getRandomComponent();\r\n      _componentBloc.add(ComponentErrorAdded(\r\n        componentName,\r\n        'Simulated malfunction detected',\r\n      ));\r\n\r\n      _componentBloc.add(ComponentStatusUpdated(\r\n        componentName,\r\n        ComponentStatus.error,\r\n      ));\r\n    } else {\r\n      // Safety error\r\n      _safetyBloc.add(SafetyErrorDetected(\r\n        SafetyError(\r\n          id: DateTime.now().millisecondsSinceEpoch.toString(),\r\n          description: 'Simulated safety error detected',\r\n          severity: _random.nextBool()\r\n              ? SafetyErrorSeverity.warning\r\n              : SafetyErrorSeverity.critical,\r\n        ),\r\n      ));\r\n    }\r\n  }\r\n\r\n  Map<String, Map<String, double>> _generateComponentUpdates() {\r\n    final updates = <String, Map<String, double>>{};\r\n\r\n    // Example component updates - you might want to adjust these based on your needs\r\n    updates['Reaction Chamber'] = {\r\n      'temperature': _generateNewValue('temperature', 150.0, 5.0),\r\n      'pressure': _generateNewValue('pressure', 1.0, 0.05),\r\n    };\r\n\r\n    updates['MFC'] = {\r\n      'flow_rate': _generateNewValue('flow_rate', 50.0, 2.0),\r\n    };\r\n\r\n    return updates;\r\n  }\r\n\r\n  Map<String, Map<String, double>> _processDependencies(\r\n    Map<String, Map<String, double>> updates,\r\n  ) {\r\n    final dependencyUpdates = <String, Map<String, double>>{};\r\n\r\n    for (var entry in updates.entries) {\r\n      final dependencies = state.dependencies[entry.key] ?? [];\r\n      for (var dependent in dependencies) {\r\n        if (entry.key == 'MFC' && entry.value.containsKey('flow_rate')) {\r\n          dependencyUpdates[dependent] = {\r\n            'flow_rate': _adjustDependentValue(\r\n              entry.value['flow_rate']!,\r\n              0.8,\r\n              0.2,\r\n            ),\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return dependencyUpdates;\r\n  }\r\n\r\n  void _checkReactionChamber() {\r\n    _componentBloc.add(ComponentInitialized('Reaction Chamber'));\r\n    // Add specific chamber checks here\r\n  }\r\n\r\n  void _checkCriticalComponents() {\r\n    // Add checks for other critical components\r\n  }\r\n\r\n  double _generateNewValue(String parameter, double setpoint, double fluctuation) {\r\n    double delta = (_random.nextDouble() * fluctuation * 2) - fluctuation;\r\n    return setpoint + delta;\r\n  }\r\n\r\n  double _adjustDependentValue(\r\n    double baseValue,\r\n    double factor,\r\n    double fluctuation,\r\n  ) {\r\n    return baseValue * factor +\r\n           _random.nextDouble() * fluctuation * 2 -\r\n           fluctuation;\r\n  }\r\n\r\n  String _getRandomComponent() {\r\n    const components = [\r\n      'Reaction Chamber',\r\n      'MFC',\r\n      'Vacuum Pump',\r\n      'Pressure Control System',\r\n    ];\r\n    return components[_random.nextInt(components.length)];\r\n  }\r\n\r\n  @override\r\n  Future<void> close() {\r\n    _simulationTimer?.cancel();\r\n    return super.close();\r\n  }\r\n}"
        }
    ]
}